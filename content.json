{"meta":{"title":"此去经年","subtitle":null,"description":"amtoaer的个人博客","author":"amtoaer","url":"https://allwens.work"},"pages":[{"title":"about","date":"2018-12-12T22:14:36.000Z","updated":"2020-10-11T02:35:42.719Z","comments":false,"path":"about/index.html","permalink":"https://allwens.work/about/index.html","excerpt":"","text":"[摸鱼划水の文文]与&nbsp;文文&nbsp; （ amtoaer ） 对话中...bot_ui_ini()","keywords":"关于"},{"title":"bangumi","date":"2019-02-10T21:32:48.000Z","updated":"2020-10-11T02:35:42.719Z","comments":false,"path":"bangumi/index.html","permalink":"https://allwens.work/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"links","date":"2018-12-19T23:11:06.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"friends/index.html","permalink":"https://allwens.work/friends/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"comment","date":"2018-12-20T23:13:48.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"message/index.html","permalink":"https://allwens.work/message/index.html","excerpt":"","text":"念两句诗叙别梦、扬州一觉。【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"music","date":"2018-12-20T23:14:28.000Z","updated":"2020-10-11T02:35:42.719Z","comments":false,"path":"music/index.html","permalink":"https://allwens.work/music/index.html","excerpt":"","text":"网易云音乐QQ音乐","keywords":"喜欢的音乐"},{"title":"说说","date":"2020-10-11T02:35:42.719Z","updated":"2020-10-11T02:35:42.719Z","comments":false,"path":"personal-space/index.html","permalink":"https://allwens.work/personal-space/index.html","excerpt":"","text":"void 0===window.artitalk&&(window.artitalk=new Artitalk),window.artitalk.init({appId:\"6PQcTkHfheSIKOymTCUbiDsc-MdYXbMMI\",appKey:\"wfyWbG3H3Yxfwq2KLiphW0NI\",pageSize:3,color1:\"#d9d9f3\",color2:\"#ceefe4\",color3:\"black\",atComment:0})","keywords":"我的小窝"},{"title":"rss","date":"2018-12-20T23:09:03.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"rss/index.html","permalink":"https://allwens.work/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T22:14:16.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"tags/index.html","permalink":"https://allwens.work/tags/index.html","excerpt":"","text":""},{"title":"video","date":"2018-12-20T23:14:38.000Z","updated":"2020-10-11T02:35:42.719Z","comments":false,"path":"video/index.html","permalink":"https://allwens.work/video/index.html","excerpt":"","text":"var videos=[{img:\"https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\",title:\"朝花夕誓——于离别之朝束起约定之花\",status:\"已追完\",progress:100,jp:\"さよならの朝に約束の花をかざろう\",time:\"放送时间: 2018-02-24 SUN.\",desc:\" 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\"},{img:\"https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg\",title:\"朝花夕誓——于离别之朝束起约定之花\",status:\"已追完\",progress:100,jp:\"さよならの朝に約束の花をかざろう\",time:\"2018-02-24 SUN.\",desc:\" 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。\"}].should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%}.should-ellipsis i{position:absolute;right:24px}.grey-text{color:#9e9e9e!important}.grey-text.text-darken-4{color:#212121!important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,:after,:before{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 3px 1px -2px rgba(0,0,0,.12),0 1px 5px 0 rgba(0,0,0,.2);box-shadow:0 2px 2px 0 rgba(0,0,0,.14),0 3px 1px -2px rgba(0,0,0,.12),0 1px 5px 0 rgba(0,0,0,.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,.2),0 6px 20px 0 rgba(0,0,0,.19);box-shadow:0 8px 17px 0 rgba(0,0,0,.2),0 6px 20px 0 rgba(0,0,0,.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right!important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:400;color:rgba(0,0,0,.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=radio]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=radio]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=radio]:not(:checked)+span:after,[type=radio]:not(:checked)+span:before{border-radius:50%}[type=radio]:not(:checked)+span:after,[type=radio]:not(:checked)+span:before{border:2px solid #5a5a5a}[type=radio]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=checkbox]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=checkbox]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,.42)}[type=checkbox].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=checkbox].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0;z-index:0}input[type=checkbox]:not(:disabled).tabbed:focus~.lever::before,input[type=checkbox]:not(:disabled)~.lever:active:before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,.26);box-shadow:0 0 0 10px rgba(38,166,154,.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,.26)}番组计划这里将是永远的回忆window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"查找相同字符串","slug":"sameString","date":"2020-09-17T15:16:11.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"sameString/","link":"","permalink":"https://allwens.work/sameString/","excerpt":"","text":"问题描述给定n个长度为m的字符串数组和一个长度为m的目标字符串，编写程序得到字符串数组中与目标字符串相同的字符串角标。举例：String[] toFind = new String[]{&quot;abca&quot;,&quot;abab&quot;,&quot;abba&quot;,&quot;abca&quot;}; String target = &quot;abca&quot;; // 结果 [0,3] 解决方法遍历最简单的方法，遍历字符串数组，与目标字符串进行对比，如果与目标字符串相等则将其角标加入到结果中，最后返回结果。List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; toFind.length; i++) { if (target.equals(toFind[i])) { result.add(i); } } return result; 字典树使用待查找字符串数组构建字典树，在根节点存储该字符串的角标。使用目标字符串到字典树中进行查找，得到结果。示意图代码实现class Main { public static void main(String[] args) { String[] toFind = new String[] { &quot;abca&quot;, &quot;abab&quot;, &quot;abba&quot;, &quot;abca&quot; }; String target = &quot;abca&quot;; TrieTreeNode root = new TrieTreeNode(); for (int i = 0; i &lt; toFind.length; i++) { root.addStringToTree(toFind[i], i); } System.out.println(root.searchInTree(target)); } } // 字典树节点的简单实现 class TrieTreeNode { // 子节点 private List&lt;TrieTreeNode&gt; list; // 存储角标 private List&lt;Integer&gt; result; // 该点字符 private char ch; // 空构造函数(构造根节点) public TrieTreeNode() { } // 构造子节点 private TrieTreeNode(char ch) { this.ch = ch; } // 判断该点字符是否为ch private boolean isChar(char ch) { if (this.ch == ch) { return true; } return false; } // 获取字符为ch的子节点(如果没有字符为ch的子节点则自动添加) private TrieTreeNode getNext(char ch) { if (list == null) { list = new ArrayList&lt;&gt;(); } for (var item : list) { if (item.isChar(ch)) { return item; } } var tmp = new TrieTreeNode(ch); list.add(tmp); return tmp; } // 使用上述private函数将字符串添加到字典树中 public void addStringToTree(String str, int index) { var tmp = this; for (var item : str.toCharArray()) { tmp = tmp.getNext(item); } if (tmp.result == null) { tmp.result = new ArrayList&lt;&gt;(); } tmp.result.add(index); } // 在字典树中查询目标字符串 public List&lt;Integer&gt; searchInTree(String target) { var tmp = this; for (var item : target.toCharArray()) { if (tmp.list == null || tmp.list.isEmpty()) { return new ArrayList&lt;Integer&gt;(); } tmp = tmp.getNext(item); } return tmp.result; } } 哈希表使用String-&gt;List&lt;Integer&gt;的哈希表，将字符串作为key，对应的角标作为value。直接通过查表返回结果。Map&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; toFind.length; i++) { if (map.get(toFind[i]) == null) { map.put(toFind[i], new ArrayList&lt;Integer&gt;()); } map.get(toFind[i]).add(i); } return map.get(target); 切割字符串后使用哈希表（作业）解释当给定的字符串过长、规模过大时，直接应用哈希表会造成较多的空间浪费。在这种情况下，我们可以将字符串进行切割，将每一个子串作为key，字符串的角标和子串位置构成的二元组列表（&lt;i,j&gt;）作为value。在查找目标字符串时，同样切割目标字符串得到子串，将每一段子串作为key查询得到二元组列表。如果二元组列表中的某个二元组（&lt;i,j&gt;）的子串位置（j）与当前子串在目标字符串中的位置相同，则说明toFind[i]的该段子串与目标字符串相同，将i加入到该子段的角标集合中。最后对目标字符串的所有字段的角标集合求交得到结果。对于结果中的每个元素i，都有toFind[i]的所有子串与目标字符串的对应子串相同。即toFind[i]与目标字符串相同。示意图代码实现（包含输入输出，上文的String[]使用List&lt;String&gt;代替）import java.util.List; import java.util.ArrayList; import java.util.Scanner; import java.util.HashMap; import java.util.HashSet; import java.util.Set; import java.util.Map; class Main { public static void main(String[] args) { // 输入的待查找的字符串 List&lt;String&gt; list = new ArrayList&lt;&gt;(); String target; try (var scanner = new Scanner(System.in)) { System.out.print(&quot;Please input target String:&quot;); // 目标字符串 target = scanner.nextLine(); System.out.println(&quot;Please input String array to find(end with space):&quot;); String tmp; // 输入非空则读入list while (!&quot;&quot;.equals(tmp = scanner.nextLine())) { list.add(tmp); } } // 输出查找结果 System.out.println(find(target, getMap(list))); } // 字符串分割函数 private static List&lt;String&gt; split(String src, int size) { List&lt;String&gt; result = new ArrayList&lt;&gt;(); int begin = 0; while (begin &lt; src.length()) { // 如果开始位置加截断长度大于源字符串长度，则只截断到字符串末尾并跳出循环 if (begin + size &gt; src.length()) { result.add(src.substring(begin)); break; } result.add(src.substring(begin, begin + size)); begin += size; } return result; } private static Map&lt;String, List&lt;Pair&gt;&gt; getMap(List&lt;String&gt; list) { Map&lt;String, List&lt;Pair&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; list.size(); i++) { String item = list.get(i); // 对待查找字符串进行分割得到List&lt;String&gt; var array = split(item, 10); // 遍历所有分割结果 for (int j = 0; j &lt; array.size(); j++) { String key = array.get(j); // 将分割结果作为key对map取value,如果为空则加入空List if (map.get(key) == null) { map.put(key, new ArrayList&lt;Pair&gt;()); } // 为List加入二元组&lt;i,j&gt;（其中i为待查找字符串的编号，j为在该字符串内的位置） map.get(key).add(new Pair(i, j)); } } return map; } private static Set&lt;Integer&gt; find(String target, Map&lt;String, List&lt;Pair&gt;&gt; map) { // target为空则返回空集合 if (target == null) { return new HashSet&lt;Integer&gt;(); } List&lt;Set&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); // 对需查找的字符串进行分割 var array = split(target, 10); // 遍历分割后的字符串数组 for (int i = 0; i &lt; array.size(); i++) { var key = array.get(i); // 与该分割段在对应位置相等的行数集合 Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); // 如果该段匹配，则将行数加入到set中 for (var item : map.get(key)) { if (item.getLast() == i) { set.add(item.getFirst()); } } // 将set加入list list.add(set); } // 如果list为空则返回空集合 if (list.isEmpty()) { return new HashSet&lt;Integer&gt;(); } // 取list中的第一个集合 Set&lt;Integer&gt; result = list.get(0); // 将该集合对所有集合取交 for (var item : list) { result.retainAll(item); } // 得到结果，返回 return result; } } // 一个简单的Pair实现（&lt;Integer,Integer&gt;） class Pair { private final Integer first; private final Integer last; public Pair(Integer first, Integer last) { this.first = first; this.last = last; } public Integer getFirst() { return this.first; } public Integer getLast() { return this.last; } @Override public boolean equals(Object compare) { if (compare == null) { return false; } Pair tmp = (Pair) compare; if (this.first == tmp.first &amp;&amp; this.last == tmp.last) { return true; } return false; } } 进一步的思考（作业）在上面的算法中，我们使用固定长度对查找域toFind和查找目标target进行切割，但使用这种方法，可能会出现某些子串出现过于频繁的情况。因此，我们可以考虑优化字符串分割算法，对出现频率过高的字符串进行顺延（即取该子串后的字符拼接到该子串后）。举例如下：// 按长度为3切割该字符串 &quot;abcedfabcqweabcertabctyu&quot; // 得到结果，可以看到abc出现频率过高，对其进行顺延 &quot;abc|edf|abc|qwe|abc|ert|abc|tyu&quot; // 顺延后，abc分化为了abce|abcq|abct，降低了这一子串的出现频率 &quot;abce|edf|abcq|qwe|abce|ert|abct|tyu&quot; 算法的注意点如何定义“频率过高”？很明显，我们需要设置一个比例来标明我们允许的子串最大的出现频率，当有子串的出现频率大于这一阈值时，我们对该子串进行顺延，尝试“分化”这一子串到一个更低的频率。重复该过程以达到最终的“所有子串出现频率均低于这一阈值”的结果。字符串切割算法的整体性。在该题目中，我们使用的方法是使用同样的规则切割查找域的每个字符串和目标字符串，对应位置进行比较，最后将对应位置相等的行数取交集得到结果。在普通的按确定长度进行切割的情况下，我们可以对所有的串单独处理。但在如今的算法框架下，如果对字符串分别处理，很可能会出现切割方式不统一的情况。因此，我们在进行子串频率统计、子串顺延等操作时，需要把{查找域，查找目标}这个字符串的集合作为整体，确保每个操作都能成功作用于查找域中的每个字符串和目标字符串。我的Java代码实现（使用递归且复杂度较高）import java.util.*; class Main { // 用于全局统计子串需要顺延的长度 private static Map&lt;String, Integer&gt; globalCount = new HashMap&lt;&gt;(); // 用于统计每次切割中子串的出现次数 private static Map&lt;String, Integer&gt; count = new HashMap&lt;&gt;(); public static void main(String[] args) { String[] range = new String[] { &quot;abcabcedf&quot;, &quot;abeabeefg&quot;, &quot;bcdbcabec&quot; }; String target = &quot;abcabcedf&quot;; // target和range的切割方式应该相同，故需要同时处理 List&lt;List&lt;String&gt;&gt; list = cutStrings(range, target, 3, 0.2); System.out.println(list); } // 得到切割后的列表，参数分别为查找域，查找目标，切割的原始长度，子串的最高出现频率 private static List&lt;List&lt;String&gt;&gt; cutStrings(String[] range, String target, int width, double pro) { // 总子串个数等于（字符串长度/切割长度）向上取整再乘以字符串个数 int totalCount = ((int) Math.ceil((double) target.length() / width)) * (range.length + 1); // 最高出现频率小于（1/总子串个数）是不可能的情况，在这种情况下直接返回空的二维数组 // （尽管进行了限制，但在特定情况下如果设置pro过低仍然可能出现stack overflow） if (pro &lt; 1.0 / totalCount) { return new ArrayList&lt;List&lt;String&gt;&gt;(); } count.clear(); List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); // 遍历查找域，按指定长度切割字符串 for (var item : range) { result.add(cutString(item, width)); } // 按指定长度切割查找目标 result.add(cutString(target, width)); // 切割完所有串后，我们在count内得到了所有子串的出现次数 // 接下來需要遍历count,将出现频率大于限制频率的子串进行标记，在下次切割时将该种子串后延 boolean flag = false; // flag用于标记是否有出现频率大于限制的字符串 for (var item : count.entrySet()) { if ((double) item.getValue() / totalCount &gt; pro) { addForGlobalCount(item.getKey().substring(0, width)); flag = true; } } // 如果所有子串出现频率都小于限制则满足要求，直接返回 if (!flag) { return result; } // 否则重新进行切割 return cutStrings(range, target, width, pro); } // 统计str出现的次数 private static void addForCount(String str) { if (count.get(str) != null) { count.put(str, count.get(str) + 1); } else { count.put(str, 1); } } // 统计子串需要顺延的长度（基本逻辑是如果顺延后仍然出现频率较高，则继续顺延） private static void addForGlobalCount(String str) { if (globalCount.get(str) != null) { globalCount.put(str, globalCount.get(str) + 1); } else { globalCount.put(str, 1); } } // 切割str并统计所有子串出现的次数(切割方法在每次循环都会通过globalCount进行校正而逐步逼近正确结果) private static List&lt;String&gt; cutString(String str, int width) { List&lt;String&gt; result = new ArrayList&lt;&gt;(); int start = 0; String sub; while (start &lt; str.length()) { // 如果到达结尾则切割到结尾 if (start + width &gt; str.length()) { sub = str.substring(start); result.add(sub); addForCount(sub); break; } Integer extraWidth; // 判断是否需要顺延 if ((extraWidth = globalCount.get(str.substring(start, start + width))) != null) { // 如果需要顺延，需要判断顺延后是否到达结尾 int tmp = start + width + extraWidth &gt; str.length() ? str.length() : start + width + extraWidth; sub = str.substring(start, tmp); } else { sub = str.substring(start, start + width); } result.add(sub); addForCount(sub); start += width; } return result; } }","categories":[{"name":"算法分析","slug":"算法分析","permalink":"https://allwens.work/categories/算法分析/"}],"tags":[{"name":"java","slug":"java","permalink":"https://allwens.work/tags/java/"},{"name":"algorithm","slug":"algorithm","permalink":"https://allwens.work/tags/algorithm/"}],"keywords":[{"name":"算法分析","slug":"算法分析","permalink":"https://allwens.work/categories/算法分析/"}]},{"title":"artitalk的使用及美化","slug":"useArtitalk","date":"2020-08-26T21:22:06.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"useArtitalk/","link":"","permalink":"https://allwens.work/useArtitalk/","excerpt":"Artitalk是一款通过leancloud实现的可实时发布说说的js。点击我博客顶部的“说说”，看到的即为artitalk界面。本文主要记录artitalk 2.4.x在pjax网站的使用方法及美化过程。","text":"Artitalk是一款通过leancloud实现的可实时发布说说的js。点击我博客顶部的“说说”，看到的即为artitalk界面。本文主要记录artitalk 2.4.x在pjax网站的使用方法及美化过程。在pjax网站使用artitalk因为artitalk并没有提供重载函数，因此目前的解决办法主要有两种：在该页面通过各种手段进行一次刷新，例如：官方文档中的方法，自动在artitalk界面刷新$(document).ready(function () { if(location.href.indexOf(&quot;#reloaded&quot;)==-1){ location.href=location.href+&quot;#reloaded&quot;; location.reload(); } }) 对于volantis主题，将artitalk页面的window.location.pathname加入到主题配置的pjax黑名单手动清除artitalk初始化的AV对象并重新加载js文件此处我们讨论的是第二种方法。参照该pr的思路，我们需要在页面重载的时候删除掉原本的window.AV对象，接着重新加载artitalk.js。数据迁移因为valine同样依赖window.AV提供服务。使用上述方法解决artitalk问题的代价是：在加载artitalk界面过程中，artitalk将valine的window.AV替换成了自己的。所以首先我们需要确保artitalk和valine使用的是相同的LeanCloud应用。按照artitalk官方文档的说法：因为 LeanCloud 功能的限制。若想同时使用 valine 和 artitalk，请在 class 中添加名为 Comment 的 class。不推荐在存储 valine 的应用中新建名为 shuoshuo 的 class，可能会出现神奇的 bug。所以我们需要将valine的数据迁移到artitalk中（如果本来用的就是相同的应用可以跳过该步骤）：在artitalk使用的LeanCloud应用中新建Comment class，如果有使用访问量功能的话还需要新建Counterclass将原来valine应用中的Comment和Counter class导出（吐槽一句：为什么只能在中午十二点前导出啊！维护用得着整整半天吗？！）将导出的Comment和Counter class导入到artitalk使用的应用中将配置文件中valine使用的ID和Key改成和artitalk相同的。具体的实现过程这一步是我自己摸索出来的，可能有些繁琐。参考该文章里重载整个js文件的实现思路，我们可以将artitalk引入到网站并加上data-pjax属性，并在每次pjax切换页面时对带有data-pjax属性的js文件进行重载。但问题是，我们并不应该让artitalk在每个页面都执行，只有位于artitalk页面时才有执行的必要，因此我们需要手动修改artitalk源码并重新构建，具体流程是：克隆Artitalk仓库并切换到指定commit查看版本历史后发现1df35c9似乎是最后通过测试的commit，因此我们使用该次commit。git clone https://github.com/ArtitalkJS/Artitalk cd Artitalk git checkout 1df35c9 有一说一，感觉这个项目有点乱。所有操作基本都在master分支，甚至使用github actions往master里push…加入对当前所处页面的判断我们需要加入对当前页面的判断，只有当前页是artitalk页时才需要执行脚本。以我的博客为例，artitalk页面的window.location.pathname为/personal-space/，我做的操作是：为src/main.js套一个判断if (window.location.pathname===&#39;/personal-space/&#39;){ // 文件原本内容 } 为av.min.js套一个判断if (window.location.pathname===&#39;/personal-space/&#39;){ if (window.AV!==undefined){ delete window.AV } // 文件原本内容 } 安装依赖并构建# for yarn yarn yarn gulp # for npm npm install npm run gulp 在网站中引入构建好的文件把dist/artitalk.min.js放入博客的source/js目录。将这行加到footer里：&lt;script data-pjax src=&#39;/js/artitalk.min.js&#39;&gt;&lt;/script&gt; 修改pjax:complete函数// 这是Valine的重载函数 VA: function () { if (!valine) { var valine = new Valine() valine.init({ el: &#39;#vcomments&#39;, appId: mashiro_option.v_appId, appKey: mashiro_option.v_appKey, path: window.location.pathname, placeholder: &#39;你是我一生只会遇见一次的惊喜 ...&#39;, visitor: true }) } } // pjax:complete内 pjax(...,...,{...}).on(&#39;pjax:complete&#39;,function (){ // 重载artitalk $(&quot;script[data-pjax], .pjax-reload script&quot;).each(function () { $(this).parent().append($(this).remove()); }); // 再重载valine VA() }) 这一步要注意顺序，实测如果先重载valine再重载artitalk，会出现valine能正确显示评论条数却不能显示内容的bug。加入artitalk页面万事具备，最后只需要在artitalk对应的md文件内写入：--- title: 标题 comments: false --- &lt;div id=&quot;artitalk_main&quot;&gt;&lt;/div&gt; &lt;script&gt; var appID=&quot;你的ID&quot;; var appKEY=&quot;你的Key&quot;; // 各种配置项请参考artitalk官方文档 &lt;/script&gt; artitalk美化（自定义样式）简单需求如果只是想换个背景色，我们可以通过简单指定配置项的color1/color2/color3来生效。例如我的博客，使用的配置是：var color1=&#39;#d9d9f3&#39;; var color2=&#39;#ceefe4&#39;; var color3=&#39;black&#39;; 复杂需求对于更复杂的美化需求，这篇文章给出了多个自定义样式。然而，但实际使用中会发现文中的自定义方法不能生效。我们来看一下artitalk添加的默认样式：#artitalk_main .cbp_tmtimeline&gt;li:nth-child(odd) .cbp_tmlabel { ...... } 再来看看自定义的样式：.cbp_tmtimeline&gt;li:nth-child(odd) .cbp_tmlabel { ...... } 根据css优先级的规则：内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器。在其他部分相同的情况下，artitalk的默认样式多使用了一个ID选择器，在优先级上是高于我们的自定义样式的，因此我们的自定义样式无法成功应用。解决方法有三种：为自定义样式同样加上ID选择器，并保证自定义样式位于默认样式后。当优先级与多个 CSS 声明中任意一个声明的优先级相等的时候，CSS 中最后的那个声明将会被应用到元素上。为自定义样式中的每个属性加上!important。当在一个样式声明中使用一个 !important 规则时，此声明将覆盖任何其他声明。指定cssurl项根据artitalk配置项文档，当我们指定cssurl项时，默认样式将不会被加载，转而使用位于cssurl的css文件。我们可以将仓库中的main.css拷贝出来，把指定的条目换成我们的自定义样式，并将修改后的css文件上传到某个网站，最后把上传后得到的直链地址填到cssurl项即可。","categories":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/网站建设/"}],"tags":[{"name":"website","slug":"website","permalink":"https://allwens.work/tags/website/"},{"name":"artitalk","slug":"artitalk","permalink":"https://allwens.work/tags/artitalk/"}],"keywords":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/网站建设/"}]},{"title":"fcitx5使用及调优","slug":"useFcitx5","date":"2020-08-17T12:45:56.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"useFcitx5/","link":"","permalink":"https://allwens.work/useFcitx5/","excerpt":"最近发现archlinuxcn群组里有很多人在用fcitx5，我也试着尝了尝鲜 。注意：fcitx5不支持搜狗输入法、百度输入法等等，对这些输入法情有独钟的用户请忽略此篇文章。作者环境：archlinux+kde。","text":"最近发现archlinuxcn群组里有很多人在用fcitx5，我也试着尝了尝鲜 。注意：fcitx5不支持搜狗输入法、百度输入法等等，对这些输入法情有独钟的用户请忽略此篇文章。作者环境：archlinux+kde。安装目前archlinux已经有了完整的fcitx5支持，对于arch用户，只需要：# 卸载fcitx4相关程序 sudo pacman -Rs $(pacman -Qsq fcitx) # 安装fcitx5框架、配置工具、输入法模块 sudo pacman -S fcitx5-im # 安装输入法引擎，目前可选fcitx5-chinese-addons/fcitx5-rime/fcitx5-chewing # rime配置较为复杂，chewing个人没有接触过，本文使用chinese-addons sudo pacman -S fcitx5-chinese-addons 即可成功安装。接着，如果想要在程序中正常启用fcitx5，需要设置一下环境变量：# 在~/.xprofile中写入以下内容 export INPUT_METHOD=fcitx5 export GTK_IM_MODULE=fcitx5 export QT_IM_MODULE=fcitx5 export XMODIFIERS=@im=fcitx5 自启动fcitx5默认不会自启动，想要让其自动启动，可选如下两种途径：通过桌面环境的自启设置添加fcitx5（以kde为例）：执行以下命令：sudo cp /usr/share/applications/fcitx5.desktop ~/.config/autostart/ 接着重启电脑，在fcitx5配置中添加所需要的输入法即可（一般用户请选择Pinyin）：皮肤目前可用的皮肤有限，推荐使用较为美观的fcitx5-material-color：sudo pacman -S fcitx5-material-color 对于其它桌面环境用户，请参照项目README.md修改配置文件进行配置。KDE用户可通过设置 -&gt; 区域设置 -&gt; 输入法 -&gt; 配置附加组件 -&gt; Classic User Inteface -&gt; 主题 切换：词库接着是至关重要的词库配置环节。目前仓库中提供了2个词库，分别是：fcitx5-pinyin-zhwiki：中文维基百科词条fcitx5-pinyin-moegirl：萌娘百科词条对于使用fcitx5-chinese-addons输入法引擎的用户，安装包即可自动启用词库。除此之外，我们还可以导入搜狗词库：对于 KDE 用户来说，可以通过 设置 -&gt; 区域设置 -&gt; 输入法 -&gt; Pinyin -&gt; 词典 -&gt; 导入 来导入搜狗词库。对于其他用户，需要手动打开 “Fcitx5 配置” 这个软件，并在拼音输入法中手动配置。遇到问题？参考arch wiki：故障处理。在该篇文章下留言提问，我会尽量解答。总结个人看来，配置好的fcitx5完全不逊色于搜狗输入法，并且更加稳定。推荐使用。参考Fcitx5 - ArchWiki","categories":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/便捷使用/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"archlinux","slug":"archlinux","permalink":"https://allwens.work/tags/archlinux/"},{"name":"input","slug":"input","permalink":"https://allwens.work/tags/input/"}],"keywords":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/便捷使用/"}]},{"title":"让.jar程序“可执行”","slug":"makeJarExecutable","date":"2020-08-07T20:12:52.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"makeJarExecutable/","link":"","permalink":"https://allwens.work/makeJarExecutable/","excerpt":"最近用java写了一个命令行版小牛翻译，通过maven构建生成.jar文件。但众所周知，.jar程序不能直接运行，而是需要使用JVM解释：java -jar filename.jar ...arguments 这导致其使用体验并不友好。那有没有什么方法让.jar程序“可执行”（不用带上java -jar）的方法呢？我去查了查，发现是有的。","text":"最近用java写了一个命令行版小牛翻译，通过maven构建生成.jar文件。但众所周知，.jar程序不能直接运行，而是需要使用JVM解释：java -jar filename.jar ...arguments 这导致其使用体验并不友好。那有没有什么方法让.jar程序“可执行”（不用带上java -jar）的方法呢？我去查了查，发现是有的。内容主要参考自这篇文章。Linux下可执行的程序有两种，二进制程序和脚本文件。前者是机器码，可以直接运行，后者则需要一个解释器，通过解释器对代码解释执行。在脚本文件中，可以通过在文件头加入hashbang指定解释器，这样在执行脚本文件时，系统会使用hashbang中指定的解释器解释脚本内容。以python为例：正常情况下，我们需要通过python filename.py来执行程序，而如果在filename.py首行加入#!/usr/bin/python并给予其可执行权限，它便可直接通过./filename.py执行。回到java，.jar文件本身是字节码的集合，java -jar表明需要用JVM去解释它。因此其实我们的处理方法和python类似：新建文件，在其开头写入hashbangtouch a echo &quot;#!/usr/bin/java -jar&quot; &gt; a 将需要解释的内容（整个.jar文件）追加到文件后cat /path/to/.jar &gt;&gt; a 给予该文件可执行权限chmod +x ./a 之后就可以将其作为普通的可执行文件使用啦！","categories":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/便捷使用/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"java","slug":"java","permalink":"https://allwens.work/tags/java/"}],"keywords":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/便捷使用/"}]},{"title":"网站服务迁移声明","slug":"websiteMigration","date":"2020-07-31T10:02:25.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"websiteMigration/","link":"","permalink":"https://allwens.work/websiteMigration/","excerpt":"","text":"网站服务迁移RSSHubhttps://jeasonlau.xyz:10000/rss =&gt; https://rss.allwens.work:10000马原毛概刷题工具https://jeasonlau.xyz:10000/test =&gt; https://learn.allwens.work:10000Cloudrevehttps://drive.jeasonlau.xyz:10000 =&gt; https://drive.allwens.work:10000预计今天中午迁移完成。","categories":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/网站建设/"}],"tags":[{"name":"website","slug":"website","permalink":"https://allwens.work/tags/website/"}],"keywords":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/网站建设/"}]},{"title":"免费获取Let's Encrypt泛域名证书","slug":"freeWildcardCertificates","date":"2020-07-30T19:10:21.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"freeWildcardCertificates/","link":"","permalink":"https://allwens.work/freeWildcardCertificates/","excerpt":"去年在GoDaddy买的jeasonlau.xyz域名即将到期，然而最近囊中羞涩续费不起了，于是考虑将网站业务迁移到allwens.work域名下。目前在jeasonlau.xyz域名下的服务主要有我的马原毛概刷题工具、用于订阅RSS的RSSHub和个人使用的Cloudreve网盘，迁移的话我打算将其挂在不同的子域名下，所以打算看看能不能免费申请一张泛域名证书，结果还真找到了教程。按着教程走了一遍，整个流程不过十分钟，非常方便，本文主要记录一下申请过程。😆","text":"去年在GoDaddy买的jeasonlau.xyz域名即将到期，然而最近囊中羞涩续费不起了，于是考虑将网站业务迁移到allwens.work域名下。目前在jeasonlau.xyz域名下的服务主要有我的马原毛概刷题工具、用于订阅RSS的RSSHub和个人使用的Cloudreve网盘，迁移的话我打算将其挂在不同的子域名下，所以打算看看能不能免费申请一张泛域名证书，结果还真找到了教程。按着教程走了一遍，整个流程不过十分钟，非常方便，本文主要记录一下申请过程。😆安装acme.shLet&#39;s Encrypt官方提供了一系列的申请方法文档，但流程比较复杂。我们使用第三方工具acme.sh来简化申请流程。首先安装acme.sh：curl https://get.acme.sh | sh 该脚本进行的操作有：将acme.sh安装到~/.acme.sh/；alias acme.sh = ~/.acme.sh/acme.sh，达到类似安装到环境变量中的效果；自动创建cronjob脚本，每天自动检测证书，如果快过期则自动更新。使用DNS-API验证获取证书参考acme.sh文档可以发现，我们可以用很多种方式进行域名验证来得到证书。因为我的服务器未备案，所以web的那几种方式用起来都不是很方便，最终我选用了DNS-API来进行验证。DNS验证指的是通过在你域名的DNS解析中加入指定的txt记录来验证你对域名的所有权，而DNS-API则是通过使用DNS提供商的API自动进行txt记录的增加和删除，达到自动验证的效果。对于不同的提供商，需要不同的API key，可以点击此处查看详细教程，此处以阿里云为例。首先在阿里云账号的API管理中获取到AccessKey ID和AccessKey Secret在服务器中执行export Ali_Key=AccessKey ID export Ali_Secret=AccessKey Secret 运行以下命令获取证书（以allwens.work为例）acme.sh --issue --dns dns_ali -d allwens.work -d *.allwens.work 完成后，证书文件将会存放在～/.acme.sh/allwens.work中，后续acme.sh将会自动更新该文件夹内的证书。我目前尚不清楚更新时是否需要API，因此为了保险又将第二步创建环境变量的语句写到了~/.zshrc中。在web服务器中使用证书因为嫌原有的路径名过长，所以我首先在/etc下新建了cert文件夹，做了一个软链接：该步骤可以跳过，我只是为了让路径短一点 🤣sudo mkdir /etc/cert cd /etc/cert ln -s ~/.acme.sh/allwens.work/allwens.work.cer ./ ln -s ~/.acme.sh/allwens.work/allwens.work.key ./ 接着打开web服务器的配置文件（以nginx为例），找到需要使用证书的Server块：# Cloudreve server { server_name drive.allwens.work; location / { proxy_pass http://localhost:5212; } client_max_body_size 30g; error_page 497 =301 https://$http_host$request_uri; listen 10000; # 加入如下内容 ssl on; ssl_certificate /etc/cert/allwens.work.cer; ssl_certificate_key /etc/cert/allwens.work.key; 接着让nginx重新加载配置文件即可：nginx -s reload","categories":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/网站建设/"}],"tags":[{"name":"website","slug":"website","permalink":"https://allwens.work/tags/website/"}],"keywords":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/网站建设/"}]},{"title":"从零开始的Java学习","slug":"learningJava","date":"2020-07-29T22:00:59.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"learningJava/","link":"","permalink":"https://allwens.work/learningJava/","excerpt":"背景马上就要大三了。从我们这届开始，学院在大三进行分方向培养，我随个人兴趣选了软件开发，于是Java成为了我的必修课……7月24日夏季学期结束之后，秉持着“反正闲着也是闲着不如找点事干”的基本原则，我开始了Java的预习（实则是摸鱼）。现在已经五天过去了，准备写个小总结。","text":"背景马上就要大三了。从我们这届开始，学院在大三进行分方向培养，我随个人兴趣选了软件开发，于是Java成为了我的必修课……7月24日夏季学期结束之后，秉持着“反正闲着也是闲着不如找点事干”的基本原则，我开始了Java的预习（实则是摸鱼）。现在已经五天过去了，准备写个小总结。教程的选择这个问题我有请教过NEU LUG群的群友，得到的建议是看慕课，但考虑了自己的实际情况，最终我还是选择了适合自己的学习方式——读文档。在这里我选用的是廖雪峰教程。至于原因，主要是自己的Git/JavaScript/Python教程看的都是他的，自然Java也优先选用了。🤣现在学习了一周，感觉教程各方面讲的都蛮细致深入，对Java 14的新特性有部分涉及，小节后常设练习题让大家巩固知识，有什么知识点不明白也可以评论请教，总体来看是一个很棒的教程。当前进度目前学习了教程前六章和第七章的部分内容，这些章节分别是：Java快速入门面向对象编程异常处理反射注解泛型集合学习体会Java快速入门这一章讲解了Java的变量类型和基本语法，总体来看和c语言相似度很高，比较容易理解，但还是有一些需要注意的地方。例如：Java12引入的switch表达式String fruit = &quot;apple&quot;; // opt = 1 int opt = switch(fruit){ case &quot;apple&quot;-&gt;1; case &quot;pear&quot; -&gt;2; } Java的数据类型需要注意的是，除了整数、浮点数、字符和布尔类型外的所有类型，在Java中都是引用类型（对象）。Java内部使用UTF-16存储字符，因此Java的字符占两个字节。为了便于操作，每种基本类型都有其对应的包装类（如int的包装类为Integer）。String是不可变的，对String重新赋值，实质上是重新开辟了一片空间并赋值，并将String指针重新指向该片空间。var关键字该关键字用于让编译器自动推断类型，类似于c++中的auto。var s = &quot;测试&quot;; // s is String 数组的遍历Java提供了类似Pythonfor ... in ...的遍历方式：String[] arr = new String[] { &quot;1&quot;, &quot;2&quot;, &quot;3&quot; }; for (var item : arr) { System.out.println(item); } 面向对象编程面向对象是老生常谈的概念了，有c++的学习基础，理解起来应该不会很困难。至于Java核心类，感觉更像是用到时再去查的东西，没必要熟练掌握。普通字段/方法和静态字段/方法就我个人理解，普通字段/方法是应用于对象（实例）的，而静态字段/方法是应用于类本身的。比如一个学生类，学生个体的姓名、年龄等应该是普通字段，而学生个数这种“类的性质”应作为静态字段。除此之外，静态方法还用于表示可以脱离实例本身而存在的功能，如：// Number类的静态方法valueOf，用于构造Number实例，不依存于某个Number Number.valueOf(); // Arrays类的静态方法sort，用于对数组进行排序，不依存于某个Arrays Arrays.sort(); final关键字final关键字主要有三个作用：用于修饰变量，表示变量不可更改用于修饰方法，表示方法不可被覆写用于修饰类，表示类不可被继承接口接口是抽象类的进一步抽象，只允许拥有公开的方法和静态且final的字段。面向对象基础的最后四节面向对象基础的最后四节：包、作用域、classpath和jar、模块阐明了Java代码的组织形式，个人感觉十分重要。刚开始看会有些懵，可以试着多读几遍（虽然我到现在也还很懵呜呜呜）。异常处理Java的异常处理采用try...catch...机制，可以将错误一层一层往上抛，该节内容较为简单，体会不多。反射反射是一种程序在运行期拿到对象信息的机制，可以在对实例一无所知的情况下调用其方法。例如：通过函数名的字符串调用函数。在这一章中我觉得较难理解的是动态代理小节（主要是不清楚有什么用），评论区有一位用户举了一个很浅显的例子，让我受益匪浅。注解在我看来，注解是一个很有用的功能。教程中举了一个很实用的例子，即用自己定义的注解进行批量的参数检查。这条评论很好地阐述了注解的作用。泛型泛型又是另一个难迈的坎，主要难点集中在后三节：擦拭法、extends通配符、super通配符。擦拭法Java的泛型实现使用擦拭法，即所有对泛型的处理工作都是编译器完成的，虚拟机对泛型一无所知。而这会导致很多问题。泛型不能使用基本类型，因为泛型的实际类型是Object。无法取得所带泛型的Class。无法判断所带泛型的类型（instanceof）。不能直接实例化T类型，需要借助额外的Class。extends和super通配符这两节主要讲在针对泛型的方法中使用extends/super通配符导致的性质差异。笼统来说就是，extends可读不可写，super可写不可读。要理解这个性质，需要明白向上转型和向下转型的区别：向上转型即通过父类引用子类，向下转型即通过子类引用父类。前者是安全的，后者是不不安全的。class Person{} class Student extends Person{} Person person = new Student(); //√ Student student = new Person(); //× 因此，&lt;? extends Integer&gt;说明泛型内必然是Integer或其子类，在这种情况下，将泛型内的Integer或其子类赋给外部的Integer是向上转型，是安全的，而将外部的Integer赋值给内部的子类是向下转型，因此会出现错误。最终体现出来的性质为“可读不可写”。&lt;? super Integer&gt;与此相反。集合第七章我目前只学了将近一半，目前感觉较为简单。该章主要讲的是基本的数据结构，如数组、链表、哈希表等等的使用方式，因为不涉及到设计和实现，该章还是蛮轻松的。未完待续…（ 随 机 更 新 ）😝","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://allwens.work/categories/学习笔记/"}],"tags":[{"name":"java","slug":"java","permalink":"https://allwens.work/tags/java/"},{"name":"study","slug":"study","permalink":"https://allwens.work/tags/study/"}],"keywords":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://allwens.work/categories/学习笔记/"}]},{"title":"arch系发行版安装windows字体","slug":"windowsFontForArchlinux","date":"2020-07-16T23:54:28.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"windowsFontForArchlinux/","link":"","permalink":"https://allwens.work/windowsFontForArchlinux/","excerpt":"背景日常生活中，总是会有一些奇奇怪怪的需求需要使用到office。对linux用户来说，虽然可以用wps代替ms office办公套件，但还会面临一个很大的问题：没有windows的字体库！试想一下，作业要求提交使用微软雅黑字体的word文档，而linux上根本没有这个字体，你要怎么办？打开老师做的ppt课件，结果因为缺少字体而处处错位，又要怎么办？…无数次面临这种问题之后，我萌生了安装windows字体的想法。","text":"背景日常生活中，总是会有一些奇奇怪怪的需求需要使用到office。对linux用户来说，虽然可以用wps代替ms office办公套件，但还会面临一个很大的问题：没有windows的字体库！试想一下，作业要求提交使用微软雅黑字体的word文档，而linux上根本没有这个字体，你要怎么办？打开老师做的ppt课件，结果因为缺少字体而处处错位，又要怎么办？…无数次面临这种问题之后，我萌生了安装windows字体的想法。注：本文记录了整个打包流程，如果想要直接获取打包好的软件包，请点击此处。安装查了查，网上的解决方法大部分是把windows的字体目录挂载过来，然而像我这种linux单系统用户肯定就不能这么操作了XD于是，我打开了万能的arch wiki，根据指引来到了ttf-ms-win10的aur界面，在安装前首先看一下作者的置顶评论：FAQ, please read before posting:I get an error that the sources cannot be downloaded: Please read the instructions on the top of the PKGBUILD.Some fonts are missing in my copy of Windows (e.g., holomdl2, corbel, chandra, …): It seems that Microsoft distributes some fonts only with some Windows versions. You can just comment out the corresponding line in the PKGBUILD and then build with “makepkg –skipchecksums”.Some fonts have different checksums: We keep the checksums synchronized with our own Windows installations that are regularly updated. Different Windows versions, different ISOs etc. may contain fonts in different versions/variants. Just build the package using “makepkg –skipchecksums”.Why does the version not correspond to the latest Windows 10 build: If fonts have not changes between builds, there is no reason to change the version number of this package.Why are some fonts (e.g., traditional chinese, japanese etc.) not included here, not even in the corresponding split packages: We currently only include fonts that are installed on a standard Windows installation, without additional feature-on-demand packages (see: https://docs.microsoft.com/en-us/typography/fonts/windows_10_font_list).嗯嗯..说的已经很明白啦，接着就先克隆一下项目：git clone https://aur.archlinux.org/ttf-ms-win10.git cd ttf-ms-win10 听他的，先看一下PKGBUILD：vim PKGBUILD 首先是一段版权声明，在windows系统以外的地方使用Microsoft fonts是违法的。估计是为了避免法律问题，它并没有自带windows的字体，而是给出了两种方法：从当前已有的windows系统获取（如果有的话我就直接挂载了啊喂！）从windows的安装包中提取所以就按着他的步骤来吧：到这里下载windows10安装包打开iso镜像，解压出sources/install.wim安装wimlib并解压wim格式sudo pacman -S wimlib # 切换到install.wim所在的目录 wimextract install.wim 1 /Windows/{Fonts/&quot;*&quot;.{ttf,ttc},System32/Licenses/neutral/&quot;*&quot;/&quot;*&quot;/license.rtf} --dest-dir fonts 将解压出的字体全都放到PKGBUILD所在目录，执行：makepkg 不出所料，果然出现了他说的第三点问题，不同windows版本可能会含有同一字体的不同版本，导致哈希值检验出错，脚本检验失败自动退出。解决办法也像他说的，只需要跳过检验就好了：makepkg –skipchecksums 经过漫长的等待，应该已经打包了很多种语言的包出来，接着只需要：sudo pacman -U ./ttf-ms-win10-zh_cn-version.pkg.tar.xz 就成功啦！","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/系统优化/"}],"tags":[{"name":"archlinux","slug":"archlinux","permalink":"https://allwens.work/tags/archlinux/"},{"name":"font","slug":"font","permalink":"https://allwens.work/tags/font/"}],"keywords":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/系统优化/"}]},{"title":"medum-一款命令行待办事项管理器","slug":"medum","date":"2020-05-23T23:09:29.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"medum/","link":"","permalink":"https://allwens.work/medum/","excerpt":"前几天整了一个命令行待办事项管理器：medum。注意到自己已经有一阵子没发过文章了，正好今晚有空，把它拿出来随便聊聊，顺便水一篇233（（名称由来这个项目叫做medum，为什么呢？因为它的开发目的是防止我忘记ddl，所以从一开始，它就是作为一个备忘录（memorandum）而被设计的。我从memorandum这个单词中取了前两个和后三个字母进行拼接，于是medum诞生了。（好随意啊XD","text":"前几天整了一个命令行待办事项管理器：medum。注意到自己已经有一阵子没发过文章了，正好今晚有空，把它拿出来随便聊聊，顺便水一篇233（（名称由来这个项目叫做medum，为什么呢？因为它的开发目的是防止我忘记ddl，所以从一开始，它就是作为一个备忘录（memorandum）而被设计的。我从memorandum这个单词中取了前两个和后三个字母进行拼接，于是medum诞生了。（好随意啊XD代码结构具体的开发初衷已经写在了README.md里，所以接下来就说说代码结构吧。下面是所有的代码文件：. ├── config │ └── config.go ├── main.go ├── output │ └── output.go ├── path │ └── path.go ├── public │ └── public.go ├── sqlite │ └── sqlite.go └── text └── text.go 每个模块的功能如下：path.go：负责获取配置文件夹路径，配置文件路径和sqlite数据库路径。config.go：负责读取配置文件，并在配置文件不存在的情况下写入默认配置。public.go：存放公共的结构体，包括在多个文件进行引用的Configuration（配置文件）、Event（事项）。sqlite.go：sqlite数据库的打开，插入，更新，查询，删除功能的实现。text.go：存放该程序近乎所有的文本信息（包括报错、提醒以及sql语句）。output.go：将配置文件的颜色映射为函数，对彩色输出函数的反射调用进行一层封装。设计思路首先从功能出发，既然要读取文件，那么获取路径是必须的，于是首先考虑实现path.go：// path.go func GetPath() string { //获取文件夹路径，路径为~/.medum path, err := homedir.Dir() if err != nil { fmt.Printf(text.HomedirError, err) os.Exit(1) } return filepath.Join(path, &quot;.medum&quot;) } // 后面获取配置文件和数据的路径很简单，在文件夹路径后加文件名就可以 有了路径，接下来就是要到路径中读取文件啦，但文件读入到哪儿呢？为了让内容有处可去，应该先实现一个配置文件的结构体。考虑到配置文件自定义的是颜色，必定需要被输出模块读取，所以将其分离放在public.go里，接着再写config.go：// public.go type Configuration struct { NumberColor string EventColor string TimeColor string } // config.go func ReadConfig() *public.Configuration { configPath := path.GetConfigPath() // 检测配置文件是否存在，不存在则写入默认配置 if _, err := os.Stat(configPath); err != nil &amp;&amp; !os.IsExist(err) { writeInitConfig(configPath) } // ... decoder := json.NewDecoder(file) conf := new(public.Configuration) // 将文件读取到conf中 err = decoder.Decode(conf) // ... return conf func writeInitConfig(configPath string) { // 首先看文件夹是否存在，如果不存在则新建 tmp := path.GetPath() if _, err := os.Stat(tmp); !os.IsExist(err) { os.Mkdir(tmp, os.FileMode(0777)) } // 接着新建配置文件 file, err := os.Create(configPath) // 创建默认配置 conf := public.Configuration{ NumberColor: &quot;red&quot;, EventColor: &quot;blue&quot;, TimeColor: &quot;yellow&quot;, } // 写入 encoder := json.NewEncoder(file) encoder.Encode(conf) } 实现了配置文件的读取，紧接着就是数据的操作了，考虑实现sqlite.go，但为了方便修改，尽量将所有的文本内容与逻辑分离，需要先写text.go，但在这之前，还要先考虑好事件结构体的内容，所以最终顺序是public.go-&gt;text.go-&gt;sqlite.go：// public.go // 包括id，事件内容，开始结束日期，当前状态 type Event struct { ID int EventContent string BeginDate int64 EndDate int64 IsEnd uint8 } // text.go const ( // 创建表，其中id自增，event为事件名，开始日期结束日期用时间戳存储。 // 状态标记方面，一个事件应该有未开始，正在进行，结束三个状态，故isEnd可取0,1,2，对应三种状态 CreateTable = `create table if not exists eventList( id integer primary key autoincrement, event varchar(100) not null, beginDate unsigned bigint not null, endDate unsigned bigint not null, isEnd smallint default 1 not null );` // 插入一行 InsertRow = `insert into eventList (event,beginDate,endDate) values (?,?,?);` // 当前时间大于结束时间则标记超时 MarkOutdate = `update eventList set isEnd=2 where ?&gt;endDate;` // 当前时间小于开始时间则标记未开始 MarkNotStart = `update eventList set isEnd=0 where ?&lt;beginDate;` // 介于开始结束之间标记正在进行 MarkInProgress = `update eventList set isEnd=1 where ? between beginDate and endDate;` // 得到所有的事件，按事件状态，结束日期排序 QueryRow = `select * from eventList order by isEnd desc,endDate` // 删除超时事件 DeleteOutDate = `delete from eventList where isEnd=2` // 对于完成了的事件，通过id删除 DeleteID = `delete from eventList where id=?` ) // sqlite.go // 打开数据库 func openSqliteDB() *sql.DB { db, err := sql.Open(&quot;sqlite3&quot;, path.GetDataPath()) if err != nil { fmt.Printf(text.OpenDBError, err) os.Exit(1) } db.Exec(text.CreateTable) return db } // 剩余函数逻辑类似，取其中之一举例： func InsertSqliteDB(eventContent string, beginDate, endDate time.Time) error { // 打开数据库 db := openSqliteDB() // 结束时关闭 defer db.Close() // 执行语句 _, err := db.Exec(text.InsertRow, eventContent, beginDate.Unix(), endDate.Unix()) return err } 接下来考虑实现output.go：// output.go // 支持的所有颜色（采用map[string]interface{}存储） var funcs = map[string]interface{}{ &quot;red&quot;: color.New(color.FgRed), &quot;blue&quot;: color.New(color.FgBlue), &quot;cyan&quot;: color.New(color.FgCyan), &quot;green&quot;: color.New(color.FgGreen), &quot;yellow&quot;: color.New(color.FgYellow), &quot;magenta&quot;: color.New(color.FgMagenta), &quot;white&quot;: color.New(color.FgWhite), &quot;black&quot;: color.New(color.FgBlack), &quot;hired&quot;: color.New(color.FgHiRed), &quot;hiblue&quot;: color.New(color.FgHiBlue), &quot;hicyan&quot;: color.New(color.FgHiCyan), &quot;higreen&quot;: color.New(color.FgHiGreen), &quot;hiyellow&quot;: color.New(color.FgHiYellow), &quot;himagenta&quot;: color.New(color.FgHiMagenta), &quot;hiwhite&quot;: color.New(color.FgHiWhite), &quot;hiblack&quot;: color.New(color.FgHiBlack), } // 使用reflect包进行动态调用 func call(m map[string]interface{}, color string, params ...interface{}) { function := reflect.ValueOf(m[color]).MethodByName(&quot;Printf&quot;) in := make([]reflect.Value, len(params)) for index, param := range params { in[index] = reflect.ValueOf(param) } function.Call(in) } // 将call进行一层封装，对外公开Call函数 func Call(color string, params ...interface{}) { call(funcs, color, params...) } 万事俱备，最后只需要在主函数中完成调用逻辑即可（当然还需要补全一些错误输出、给用户的提示等等，不过那些已经很简单了）：// main.go // 接受的命令行参数 var ( begin string end string name string remove bool done int ) func main() { app := &amp;cli.App{ // 省略掉参数绑定等流程 Action: func(c *cli.Context) error { // 读取配置文件 conf := *config.ReadConfig() if remove { // -r：首先标记过期事件，接着删除之 sqlite.UpdateSqliteDB(text.MarkOutdate) err := sqlite.DeleteOutDate() if err != nil { fmt.Printf(text.DeleteOutdateError, err) os.Exit(1) } fmt.Println(text.DeleteOutdateSuccess) } else if done != 0 { // -d int： 直接删除该id err := sqlite.DeleteID(done) if err != nil { fmt.Printf(text.DeleteIDError, err) os.Exit(1) } fmt.Println(text.DeleteIDSuccess) } else { if len(end) == 0 { // 如果没有-d，打印事件列表 // 这里只标记进行中和超时，是因为在插入事件时已经标记了是否未开始，时间顺序流动，不可能从开始变为未开始 sqlite.UpdateSqliteDB(text.MarkInProgress) sqlite.UpdateSqliteDB(text.MarkOutdate) // ...省略输出部分 } } else { // 如果存在-e，则解析结束时间，开始事件如果有就解析，没有默认为当前时间 var beginTime, endTime time.Time endTime = handleString(end) if len(begin) == 0 { beginTime = time.Now() } else { beginTime = handleString(begin) } if beginTime.Unix() &gt;= endTime.Unix() { fmt.Println(text.TimeError) os.Exit(1) } // 将输入事件插入 err := sqlite.InsertSqliteDB(name, beginTime, endTime) if err != nil { fmt.Printf(text.InsertDBError, err) } // 标记未开始 sqlite.UpdateSqliteDB(text.MarkNotStart) fmt.Println(text.InsertSuccess) } } return nil }} err := app.Run(os.Args) if err != nil { log.Fatal(err) } } func handleString(tm string) time.Time { // 时间字符串转time.Time，只接受month.day.hour.minute格式 tmp := strings.Split(tm, &quot;.&quot;) // 长度不为4则退出 if len(tmp) != 4 { fmt.Println(text.LengthError) os.Exit(1) } else { // 补全0，例如将5.20.12.0补全为05.20.12.00，防止解析错误 for index := range tmp { if len(tmp[index]) == 1 { tmp[index] = &quot;0&quot; + tmp[index] } } stdString := fmt.Sprintf(text.MyTime, strconv.Itoa(time.Now().Year()), tmp[0], tmp[1], tmp[2], tmp[3]) result, err := time.ParseInLocation(text.StandardTime, stdString, time.Now().Local().Location()) if err != nil { fmt.Printf(text.ParamError, err) os.Exit(1) } return result } //useless line, just to prevent warning return time.Now() } func formatTime(begin, end int64, IsEnd uint8) string { // 将时间转换成%s time remaining/%s time beginning格式，其中的%s调用下面的formatTimeString函数获取 now := time.Now() if IsEnd == 0 { beginTime := time.Unix(begin, 0) dur := beginTime.Sub(now) return fmt.Sprintf(text.TimeBeginning, formatTimeString(dur.Minutes())) } else if IsEnd == 1 { endTime := time.Unix(end, 0) dur := endTime.Sub(now) return fmt.Sprintf(text.TimeRemaining, formatTimeString(dur.Minutes())) } else { return fmt.Sprintf(text.TimeRemaining, &quot;no time&quot;) } } func formatTimeString(min float64) string { // 获取天/小时/分钟 var tmp string if min &gt; 1440 { tmp = strconv.Itoa(int(min/1440)) + &quot; days&quot; } else if min &gt; 60 { tmp = strconv.Itoa(int((min / 60))) + &quot; hours&quot; } else { tmp = strconv.Itoa(int(min)) + &quot; minutes&quot; } return tmp } 这样下来，预想的功能就实现的差不多了，任务成功完成。结束语okk，这样就结束啦，算是写了个小总结吧。代码基本全程都有注释（不过为了符合golang的规范，使用的是塑料英语XD），觉得自己代码写的还是蛮易读的，欢迎大家阅读给出建议哦！","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://allwens.work/categories/开发记录/"}],"tags":[{"name":"go","slug":"go","permalink":"https://allwens.work/tags/go/"}],"keywords":[{"name":"开发记录","slug":"开发记录","permalink":"https://allwens.work/categories/开发记录/"}]},{"title":"为typora集成sm.ms图床，纵享丝滑体验","slug":"typora","date":"2020-04-28T20:01:51.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"typora/","link":"","permalink":"https://allwens.work/typora/","excerpt":"起因是安利一位同学使用typora写markdown，他那里上官网比较慢，所以我去帮他下载，闲来无聊顺便逛了逛。逛完才发现，原来typora有那么多自定义选项！（没错我这一年多一直用的默认设置XD）以此为契机，我第一次打开了它的偏好设置，查看了各类选项， 发现里面有一个很有意思的功能：插入图片自动上传，觉得挺方便的，于是准备配置一波…注意：笔者使用的是linux，windows请酌情参考（安装方法和配置文件路径会略有差异）","text":"起因是安利一位同学使用typora写markdown，他那里上官网比较慢，所以我去帮他下载，闲来无聊顺便逛了逛。逛完才发现，原来typora有那么多自定义选项！（没错我这一年多一直用的默认设置XD）以此为契机，我第一次打开了它的偏好设置，查看了各类选项， 发现里面有一个很有意思的功能：插入图片自动上传，觉得挺方便的，于是准备配置一波…注意：笔者使用的是linux，windows请酌情参考（安装方法和配置文件路径会略有差异）安装typora中可选的上传配置有Picgo，Picgo-core，custom command和none，本人很久前用过Picgo，但其使用electron构建的UI在linux上体验属实很差，所以此处我选用了命令行版的Picgo-core。首先进行安装：npm install picgo -g # or yarn global add picgo 插件配置注意：windows用户请确保将picgo添加到环境变量，否则需要把下文中的所有picgo替换为path+picgo（例：C:\\picgo\\picgo.exe）Picgo本身支持多种图床上传，我选用的是方便免费的SM.MS，于项目主页我们了解到：PicGo 本体支持如下图床：SM.MS v1.5.1 由于官方不再支持V1版本，暂时请使用smms-user插件也就是说我们需要额外安装插件才可以正常使用SM.MS图床进行上传，于是打开terminal，执行：picgo install smms-user 安装成功后，我们仍然需要对其进行配置。执行以下命令：picgo config plugin smms-user ? Auth 你需要在此处输入你的TOKEN，首先到SM.MS网站注册一个账户，接着访问该链接获取TOKEN并输入，你应该会收到以下提示信息：[PicGo SUCCESS]: Configure config successfully! 接下来是最后一步，你需要把你使用的uploader修改为smms-user，在命令行中执行：picgo config uploader ? Choose a(n) uploader (Use arrow keys) ❯ smms-user smms tcyun github qiniu imgur aliyun (Move up and down to reveal more choices) 移动箭头并选中smms-user，点击回车，此时你位于~/.picgo/config.json的配置文件内容应该形如：{ &quot;picBed&quot;: { &quot;current&quot;: &quot;smms-user&quot;, &quot;uploader&quot;: &quot;smms-user&quot;, &quot;transformer&quot;: &quot;path&quot;, &quot;smms-user&quot;: { &quot;Authorization&quot;: &quot;your token&quot; } }, &quot;picgoPlugins&quot;: { &quot;picgo-plugin-smms-user&quot;: true }, &quot;picgo-plugin-smms-user&quot;: { &quot;Authorization&quot;: &quot;your token&quot; } } 图片上传服务配置成功完成！typora集成配置完上传服务，接下来在typora对接一下即可。打开typora偏好设置，在上传服务设定栏选custom command（这里解释一下，选择Picgo-core只能使用其规定的路径，我们自己指定路径还是需要用custom command），然后在下面的文本框输入：picgo upload 对接完成！接下来可以尝试点击旁边的“验证图片上传选项”按钮，测试上传是否成功了。小提示目前仅支持把文件拖动到typora中完成上传，如果直接从剪切板粘贴，typora会自动将该图片放到~/upload文件夹下但不会自动上传，需要自己手动点击“上传图片”。这是typora本身的bug：This should be a bug, there’s no need to create the “upload” folder.详见#3331.参考PicgoPicgo-corepicgo-plugin-smms-userPicgo-core document","categories":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/便捷使用/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"image","slug":"image","permalink":"https://allwens.work/tags/image/"}],"keywords":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/便捷使用/"}]},{"title":"配置世纪互联版onedrive，实现网络共享文件夹","slug":"configOnedrive","date":"2020-03-03T22:00:24.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"configOnedrive/","link":"","permalink":"https://allwens.work/configOnedrive/","excerpt":"背景很久之前就想有一个网络共享文件夹，即一个既能在本地当做普通文件夹使用，也能通过互联网访问到的文件夹。大致对比了一下这些可能能够用于实现该功能的服务：服务优点缺点以百度云为代表的国内网盘存储空间大对linux支持差，访问速度慢google drive/mega等国外网盘linux客户端支持存储空间较小，国内速度慢甚至无法连通各类oss服务（例：阿里云oss）官方挂载支持，速度无限制存储费用、流量费用、请求费用累计，代价昂贵服务器空闲存储空间可通过sftp访问受服务器带宽限制，使用效果并不理想","text":"背景很久之前就想有一个网络共享文件夹，即一个既能在本地当做普通文件夹使用，也能通过互联网访问到的文件夹。大致对比了一下这些可能能够用于实现该功能的服务：服务优点缺点以百度云为代表的国内网盘存储空间大对linux支持差，访问速度慢google drive/mega等国外网盘linux客户端支持存储空间较小，国内速度慢甚至无法连通各类oss服务（例：阿里云oss）官方挂载支持，速度无限制存储费用、流量费用、请求费用累计，代价昂贵服务器空闲存储空间可通过sftp访问受服务器带宽限制，使用效果并不理想可以看到各个服务各有优缺点。但最近，我发现了另一款产品：世纪互联版onedrive。它是微软委托国内的世纪互联运营的，对比onedrive国际版，一方面其数据中心位于北京/上海，极大地优化了国内用户的访问速度；另一方面，淘宝有大量低价号贩售，五六十块即可买到“永久”的5T存储空间（此处存疑）。上网查询，发现这个世纪互联版onedrive在本地可以通过魔改rclone实现挂载，在云端可以使用魔改oneindex、zfile等开源项目实现浏览器访问（不走服务器流量，无限速），完美满足我的需求，于是入了一个，准备开搞。需要一台自己的电脑一台服务器开放api的世纪互联版onedrive账号（一定要是开放api的！）云端先说简单的云端访问，我使用的是zfile（因为它配置简单，原生支持世纪互联onedrive）。接下来操作以ubuntu为例，centos请移步官方文档。ssh到服务器，首先安装依赖：sudo apt install -y openjdk-8-jre-headless unzip 下载项目，解压并给予可执行权限：cd ~ wget https://c.jun6.net/ZFILE/zfile-release.war mkdir zfile &amp;&amp; unzip zfile-release.war -d zfile &amp;&amp; rm -rf zfile-release.war chmod +x zfile/bin/*.sh 启动项目：~/zfile/bin/start.sh 接下来访问http://你的公网ip:8080/#/install进行配置。其中的访问令牌和刷新令牌需要访问这个网址登录账号后获取，填写成功之后点击确认即配置完成，可以在网页访问到你的onedrive云盘了！本地接下来配置稍微复杂点儿的本地挂载。以下内容转载自znov的博客，因为他是在服务器挂载，而我是在本机，所以做了少量修改。(windows只需要进行前三步，未经过实测)。世纪互联 OneDrive 获取 CLIENT_ID 及 CLIENT_SECRET打开该网页登录账号。左侧找到Azure Active Directory点击左侧找到 应用注册 点击上方找到 新注册 点击名称：onedrive受支持的账户类型：任何组织目录（第二个）重定向 URL：http://localhost:53682点击注册找到 应用程序(客户端) ID 复制保存左侧找到 证书和密码 点击下方 客户端密码 - 新建客户端密码说明：onedrive截止期限：默认 一年内点击 添加，值复制保存左侧找到 API 权限 点击添加权限：Microsoft Graph - 委托的权限：全部勾选（这里经我测试只勾选File栏即可）安装配置rclone此处下载rclone世纪互联版该文件来源于全球主机论坛爱纯粹大佬，因为原博客的下载链接速度很慢，所以另存了一份。希望大家下载的同时可以顺便去原博客评论支持一下！linux在当前目录打开terminal，执行sudo mv ./rclone的文件名 /usr/bin/rclone sudo chmod +x /usr/bin/rclone windows请自行查阅如何将文件添加到环境变量中。注：此步骤非必须，如未执行则将以下语句的rclone改为rclone的路径形式。输入rclone config进行如下配置e) Edit existing remote n) New remote d) Delete remote r) Rename remote c) Copy remote s) Set configuration password q) Quit config e/n/d/r/c/s/q&gt; n name&gt;onedrive Type of storage to configure. Enter a string value. Press Enter for the default (&quot;&quot;). Choose a number from below, or type in your own value 1 / 1Fichier \\ &quot;fichier&quot; 2 / Alias for an existing remote \\ &quot;alias&quot; 3 / Amazon Drive \\ &quot;amazon cloud drive&quot; 4 / Amazon S3 Compliant Storage Provider (AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, etc) \\ &quot;s3&quot; 5 / Backblaze B2 \\ &quot;b2&quot; 6 / Box \\ &quot;box&quot; 7 / Cache a remote \\ &quot;cache&quot; 8 / Citrix Sharefile \\ &quot;sharefile&quot; 9 / Dropbox \\ &quot;dropbox&quot; 10 / Encrypt/Decrypt a remote \\ &quot;crypt&quot; 11 / FTP Connection \\ &quot;ftp&quot; 12 / Google Cloud Storage (this is not Google Drive) \\ &quot;google cloud storage&quot; 13 / Google Drive \\ &quot;drive&quot; 14 / Google Photos \\ &quot;google photos&quot; 15 / Hubic \\ &quot;hubic&quot; 16 / JottaCloud \\ &quot;jottacloud&quot; 17 / Koofr \\ &quot;koofr&quot; 18 / Local Disk \\ &quot;local&quot; 19 / Mail.ru Cloud \\ &quot;mailru&quot; 20 / Mega \\ &quot;mega&quot; 21 / Microsoft Azure Blob Storage \\ &quot;azureblob&quot; 22 / Microsoft OneDrive \\ &quot;onedrive&quot; 23 / OpenDrive \\ &quot;opendrive&quot; 24 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH) \\ &quot;swift&quot; 25 / Pcloud \\ &quot;pcloud&quot; 26 / Put.io \\ &quot;putio&quot; 27 / QingCloud Object Storage \\ &quot;qingstor&quot; 28 / SSH/SFTP Connection \\ &quot;sftp&quot; 29 / Transparently chunk/split large files \\ &quot;chunker&quot; 30 / Union merges the contents of several remotes \\ &quot;union&quot; 31 / Webdav \\ &quot;webdav&quot; 32 / Yandex Disk \\ &quot;yandex&quot; 33 / http Connection \\ &quot;http&quot; 34 / premiumize.me \\ &quot;premiumizeme&quot; Storage&gt;22 ** See help for onedrive backend at: https://rclone.org/onedrive/ ** Microsoft App Client Id Leave blank normally. Enter a string value. Press Enter for the default (&quot;&quot;). client_id&gt;输入上面“应用程序（客户端）id” Microsoft App Client Secret Leave blank normally. Enter a string value. Press Enter for the default (&quot;&quot;). client_secret&gt;输入上面申请到的“值” OneDrive operated by 21Vianet (世纪互联). Enter a boolean value (true or false). Press Enter for the default (&quot;false&quot;). is_21vianet_version&gt;true Edit advanced config? (y/n) y) Yes n) No y/n&gt;n Use auto config? * Say Y if not sure * Say N if you are working on a remote or headless machine y) Yes n) No y/n&gt;y 之后会自动打开一个网页，在这个网页里进行登录，然后继续.. Choose a number from below, or type in an existing value 1 / OneDrive Personal or Business \\ &quot;onedrive&quot; 2 / Root Sharepoint site \\ &quot;sharepoint&quot; 3 / Type in driveID \\ &quot;driveid&quot; 4 / Type in SiteID \\ &quot;siteid&quot; 5 / Search a Sharepoint site \\ &quot;search&quot; Your choice&gt; 1 Found 1 drives, please select the one you want to use: 0: OneDrive (business) id=****** Chose drive to use:&gt;0 Found drive &#39;root&#39; of type &#39;business&#39;, URL: https://alphaone-my.sharepoint.cn/personal/*** Is that okay? y) Yes n) No y/n&gt;y y q 进行挂载linux需要安装fuse，各大发行版不一样就不详述了，我的manjaro自带。命令如下：（其中的/表示需要挂载到本地的onedrive路径，/mnt/表示本机的挂载路径，可对应修改）挂载命令：rclone mount onedrive:/ /mnt/ --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000 后台挂载命令：nohup rclone mount onedrive:/ /mnt --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000 &gt;/dev/null 2&gt;&amp;1 &amp; 卸载命令：fusermount -qzu LocalFolder onedrive 使用挂载脚本这个挂载脚本能够实现基本的挂载、卸载和重新挂载功能，之后使用的话就没有必要输入那么长的命令了。脚本如下：#!/bin/bash # ------------------------------------------ PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/bin export PATH ### BEGIN INIT INFO # Provides: rclone # Required-Start: $all # Required-Stop: $all # Default-Start: 2 3 4 5 # Default-Stop: 0 1 6 # Short-Description: Start rclone at boot time # Description: Enable rclone by daemon. ### END INIT INFO # ------------------------------------------ # 以上两条横线之间的内容不自启的话可以去掉（个人觉得自启的话去掉应该也没啥影响） NAME_BIN=&quot;rclone&quot; NAME=&quot;onedrive&quot; REMOTE=&#39;/&#39; #需要挂载到本地的onedrive路径，可修改 LOCAL=&#39;/mnt/&#39; #挂载到本地的哪个文件夹，可修改 Green_font_prefix=&quot;\\033[32m&quot; &amp;&amp; Red_font_prefix=&quot;\\033[31m&quot; &amp;&amp; Green_background_prefix=&quot;\\033[42;37m&quot; &amp;&amp; Red_background_prefix=&quot;\\033[41;37m&quot; &amp;&amp; Font_color_suffix=&quot;\\033[0m&quot; Info=&quot;${Green_font_prefix}[信息]${Font_color_suffix}&quot; Error=&quot;${Red_font_prefix}[错误]${Font_color_suffix}&quot; RETVAL=0 check_running(){ PID=&quot;$(ps -C $NAME_BIN -o pid= |head -n1 |grep -o &#39;[0-9]\\{1,\\}&#39;)&quot; if [[ ! -z ${PID} ]]; then return 0 else return 1 fi } do_start(){ check_running if [[ $? -eq 0 ]]; then echo -e &quot;${Info} $NAME_BIN (PID ${PID}) 正在运行...&quot; &amp;&amp; exit 0 else fusermount -zuq $LOCAL &gt;/dev/null 2&gt;&amp;1 mkdir -p $LOCAL /usr/bin/rclone mount $NAME:$REMOTE $LOCAL --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000 &gt;/dev/null 2&gt;&amp;1 &amp; check_running if [[ $? -eq 0 ]]; then echo -e &quot;${Info} $NAME_BIN 启动成功 !&quot; else echo -e &quot;${Error} $NAME_BIN 启动失败 !&quot; fi fi } do_stop(){ check_running if [[ $? -eq 0 ]]; then kill -9 ${PID} RETVAL=$? if [[ $RETVAL -eq 0 ]]; then echo -e &quot;${Info} $NAME_BIN 停止成功 !&quot; else echo -e &quot;${Error} $NAME_BIN 停止失败 !&quot; fi else echo -e &quot;${Info} $NAME_BIN 未运行&quot; RETVAL=1 fi fusermount -zuq $LOCAL &gt;/dev/null 2&gt;&amp;1 fusermount -zuq $LOCAL1 &gt;/dev/null 2&gt;&amp;1 } do_status(){ check_running if [[ $? -eq 0 ]]; then echo -e &quot;${Info} $NAME_BIN (PID $(echo ${PID})) 正在运行...&quot; else echo -e &quot;${Info} $NAME_BIN 未运行 !&quot; RETVAL=1 fi } do_restart(){ do_stop do_start } case &quot;$1&quot; in start|stop|restart|status) do_$1 ;; *) echo &quot;使用方法: $0 { start | stop | restart | status }&quot; RETVAL=1 ;; esac exit $RETVAL 假设该脚本被保存为rcloned，首先给予可执行权限：chmod +x rcloned的路径 之后可以选择将其移动到环境变量中，使用的时候手动执行rcloned start：sudo mv rcloned的路径 /usr/bin/rcloned # 每次使用时 rcloned start 也可以选择像原文那样设置为开机自动运行（可能不支持所有发行版）：sudo mv rcloned的路径 /etc/init.d/rcloned sudo /etc/init.d/rcloned start 截图碎碎念本来打算稍微写写水一篇文章的，没想到一不小心写了这么多…中间某些步骤写的过分详细了，希望大家阅读的时候不要嫌我啰嗦 orz参考zfile官方文档znov的博客Zephyr 杂货铺（我购买账号的地方）","categories":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/便捷使用/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"onedrive","slug":"onedrive","permalink":"https://allwens.work/tags/onedrive/"}],"keywords":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/便捷使用/"}]},{"title":"从oh my zsh到oh my fish","slug":"zshToFish","date":"2020-02-29T21:32:44.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"zshToFish/","link":"","permalink":"https://allwens.work/zshToFish/","excerpt":"为什么今天连发两篇文章呢？大概是想纪念一下四年一度的2.29吧（笑起因众所周知，shell有很多种，其中最常用的有bash和zsh，而oh my zsh是基于zsh的一个拓展工具集，自从接触linux，我一直在使用zsh &amp; oh my zsh。它易用，易拓展，但也有一个很大的缺点：太！慢！了！","text":"为什么今天连发两篇文章呢？大概是想纪念一下四年一度的2.29吧（笑起因众所周知，shell有很多种，其中最常用的有bash和zsh，而oh my zsh是基于zsh的一个拓展工具集，自从接触linux，我一直在使用zsh &amp; oh my zsh。它易用，易拓展，但也有一个很大的缺点：太！慢！了！想象你需要打开terminal切换到blog路径，运行terminal的瞬间，你开始输入命令，你希望看到的结果：~ ⟩ j blog /home/jeasonlau/File/blog ~/File/blog ⟩ 但实际的结果却是：j ~ ⟩ blog unknown command : blog ~ ⟩ 惊不惊喜？意不意外？在多次遭遇这种状况后，我实在无法忍受，开始了更换shell之路…更换曾经也听说过另一款著名的shell：fish。在NEU lug群里吐槽zsh慢的时候，意外发现几位群友都在使用fish，于是决定更换。搜索fish文档，发现arch系发行版可以直接安装，于是sudo pacman -S fish 安装成功之后，使用chsh -s /usr/local/bin/fish 将默认shell更换为fish。体验一番后感觉确实比zsh快了不少，同时原生支持命令高亮、命令建议等功能，不需要自己去手动配置，可以说是开箱即用了。主题更换成功之后，更重要的任务是换主题！秉持着(命令行不花里胡哨怎么行！)的基本原则，我开始搜索fish的主题推荐，虽然没有找到什么结果，但让我发现了另一个东西：oh my fish。它是一个类似oh my zsh的，对fish shell进行拓展的工具，具体来说包括插件和主题，于是参考文档进行安装：curl -L https://get.oh-my.fish | fish 安装完成之后就可以在available themes里进行挑选啦，找到心仪的主题后只需要执行omf install &lt;theme name&gt; 即可成功安装。把全部主题看了一遍，顺便做一下主题推荐吧。我个人喜欢的有四款：pure（慎用）该主题是我在zsh上使用的主题，也被移植到了fish上，但试用后发现其兼容并不好，总会出一些奇奇怪怪的问题，但因为日久生情，还是将其排在第一位吧。clearance另一款极简主题，实际使用效果和pure相差不多，只是截图显得比较丑。tomita截图很好看，但默认颜色与截图有部分不同，同时因为鱼标的颜色默认为浅黄，对亮色背景不够友好。（当然也可以自行修改配置文件来修改颜色）nai如果上面的是极简，这个就是极度极简，但麻雀虽小五脏俱全，简简单单反而有种别样的魅力。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/系统优化/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"manjaro","slug":"manjaro","permalink":"https://allwens.work/tags/manjaro/"}],"keywords":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/系统优化/"}]},{"title":"一个简单的命令行图床上传工具","slug":"uploadImage","date":"2020-02-29T13:37:06.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"uploadImage/","link":"","permalink":"https://allwens.work/uploadImage/","excerpt":"昨天使用缩狗图床api写了个命令行图床上传工具，支持指定使用的图床，支持单文件/多文件/多目录（非递归）上传。虽然代码很简单，但还是准备记录一下（因为想水篇文章XD","text":"昨天使用缩狗图床api写了个命令行图床上传工具，支持指定使用的图床，支持单文件/多文件/多目录（非递归）上传。虽然代码很简单，但还是准备记录一下（因为想水篇文章XD获取api既然要使用api，当然要获取api啦，首先看一下网站源码（此处只摘录了有用部分）：&lt;!--图床的选择--&gt; &lt;div class=&quot;bodyer&quot;&gt; &lt;label&gt;&lt;input name=&quot;keke&quot; checked=&quot;checked&quot; type=&quot;radio&quot; value=&quot;1688&quot;&gt;阿里图床&lt;/label&gt; &lt;label&gt;&lt;input name=&quot;keke&quot; type=&quot;radio&quot; value=&quot;tieba&quot;&gt;百度图床&lt;/label&gt; &lt;label&gt;&lt;input name=&quot;keke&quot; type=&quot;radio&quot; value=&quot;360&quot;&gt;360图床&lt;/label&gt; &lt;label&gt;&lt;input name=&quot;keke&quot; type=&quot;radio&quot; value=&quot;taobao&quot;&gt;淘宝图床&lt;/label&gt; &lt;label&gt;&lt;input name=&quot;keke&quot; type=&quot;radio&quot; value=&quot;smms&quot;&gt;SM.MS图床&lt;/label&gt; &lt;label&gt;&lt;input name=&quot;keke&quot; type=&quot;radio&quot; value=&quot;sohu&quot;&gt;搜狐图床&lt;/label&gt; &lt;label&gt;&lt;input name=&quot;keke&quot; type=&quot;radio&quot; value=&quot;jd&quot;&gt;京东图床&lt;/label&gt; &lt;/div&gt; &lt;!--图片的上传--&gt; &lt;script&gt; var imagesUpload = function (files) { a = $(&#39;input:radio:checked&#39;).val(); $(files).each(function (key, value) { setTimeout(function () { uurrll = &#39;https://pic.suo.dog/api/tc.php?type=&#39; + a + &#39;&amp;echo=imgurl&#39; image_form = new FormData(); image_form.append(&quot;file&quot;, value); $.ajax({ url: uurrll, type: &#39;POST&#39;, data: image_form, contentType: false, cache: false, processData: false, async: false, success: function (data) { if (typeof (data) == &#39;string&#39;) { imgurl = data } else { imgurl = data.imgurl } }, error: function (XMLResponse) { alert(&quot;error:&quot; + XMLResponse.responseText); } }); }, 100); }) }; &lt;/script&gt; 上面的代码还是很清楚的，用选择器获取当前选中radio的value，使用其拼接需要请求的api，接着用ajax将文件数据post到api，成功后返回图片的地址。开始编写有了api，接下来就很简单了，基本思路就是：打开文件使用requests进行post输出返回的图片url使用了requests/click/os三个包。缺少的包可以使用sudo pip install 包名安装。首先将允许的图片文件拓展名和api地址设置为全局变量：# 这里列举了几种常见的图片格式，其它格式可以修改后自行测试 allowedExtension = [&#39;.jpeg&#39;, &#39;.bmp&#39;, &#39;.jpg&#39;, &#39;.png&#39;, &#39;.webp&#39;] url = &#39;&#39; 接着使用click为main函数增加命令行参数：@click.command() @click.option(&#39;--type&#39;, &#39;-t&#39;, default=&#39;1688&#39;, type=click.Choice([&#39;1688&#39;, &#39;tieba&#39;, &#39;360&#39;, &#39;taobao&#39;, &#39;smms&#39;, &#39;sohu&#39;, &#39;jd&#39;]), help=&#39;image hosting service.&#39;) @click.argument(&#39;paths&#39;, nargs=-1, type=click.Path(exists=True, readable=True)) --type/-t option用于指定使用的图床，限制了图床的选择范围，默认使用阿里图床，paths argument接受多个路径参数，在此处保证了目录存在并可读。然后是main函数：def main(type, paths): global url url = &#39;https://pic.suo.dog/api/tc.php?type={}&amp;echo=imgurl&#39;.format(type) count = 0 print(&#39;\\033[33m开始上传...\\033[0m&#39;) for path in paths: if os.path.isdir(path): if not path.endswith(&#39;/&#39;): path += &#39;/&#39; items = os.listdir(path) for item in items: if os.path.isfile(path + item): count += uploadFile(path + item) else: count += uploadFile(path) print(&#39;\\033[33m上传完成，共上传{}张图片!\\033[0m&#39;.format(count)) 类似于\\033[33m开始上传...\\033[0m的格式是为了实现彩色输出，详情见该文章。使用获取到的type组成url，使用count标记上传图片的张数，遍历所有的路径参数，如果该路径参数为目录，则尝试上传该目录的所有文件，如果该路径参数为文件，则直接尝试上传该文件。最后输出上传的图片张数。之后是核心的上传函数：def uploadFile(file): if os.path.splitext(file)[-1] in allowedExtension: postContent = {&#39;file&#39;: open(file, &#39;rb&#39;)} with requests.post(url, files=postContent) as response: print(&#39;\\033[31m{}\\033[0m : \\033[4;32m{}\\033[0m&#39;.format( os.path.basename(file), response.text)) return 1 else: return 0 判断拓展名是否允许，如果允许则将该文件用二进制打开，post给api，输出文件名和上传的地址，返回1，否则返回0。最后的内容就不用说了：if __name__ == &#39;__main__&#39;: main() 使用截图该截图同样使用该工具上传（使用阿里图床/--type 1688）结语啊，没想到这么几行代码居然能水这么长一篇文章！（滑稽目前1688图床可以正常使用，其它图床没有测试，如果有什么问题的话可以反馈给我。","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://allwens.work/categories/开发记录/"}],"tags":[{"name":"python","slug":"python","permalink":"https://allwens.work/tags/python/"},{"name":"image","slug":"image","permalink":"https://allwens.work/tags/image/"}],"keywords":[{"name":"开发记录","slug":"开发记录","permalink":"https://allwens.work/categories/开发记录/"}]},{"title":"大二下学期即将开始啦！","slug":"newTerm","date":"2020-02-23T16:52:32.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"newTerm/","link":"","permalink":"https://allwens.work/newTerm/","excerpt":"又是好长一段时间过去了！这些天因为病毒侵袭一直宅在家里。浑浑噩噩地度过了难熬的寒假，总算是盼来了新学期！（不是","text":"又是好长一段时间过去了！这些天因为病毒侵袭一直宅在家里。浑浑噩噩地度过了难熬的寒假，总算是盼来了新学期！（不是课表说到新学期，第一想到的当然是新课表啦。下面是我的课表：授课因为病毒的影响，前几周只能老老实实在家里上网课了。大概就是这些，目前还有几门课没有通知，先不管啦…科目授课方式具体内容备注人工智能MOOC+BB+QQ群参见BB平台无数字逻辑与数字系统雨课堂直播+MOOC+BB+QQ群参见BB平台需要提前安装Altera Quartus 13.1或更高版本算法设计与分析未知无无汇编语言程序设计BB+QQ群参见BB平台记得按时提交作业（平时成绩50分，作业占很大比例）编译原理未知无无形势与政策优课堂无作业要写2000字时事评论（纸版），返校后上交思想政治理论实践课未知无无体育（羽毛球）MOOC+体适能训练无MOOC为《八法五步拳》最后明天就要上课了，就目前来看，网课属实不大方便。一方面老师需要花费额外时间熟悉平台使用，另一方面，学生们需要时刻关注这些平台，平台过于分散也给学生们带来了很大的困扰。希望疫情快快结束，大家能尽快回归到自己的日常生活吧。","categories":[{"name":"生活点滴","slug":"生活点滴","permalink":"https://allwens.work/categories/生活点滴/"}],"tags":[{"name":"study","slug":"study","permalink":"https://allwens.work/tags/study/"}],"keywords":[{"name":"生活点滴","slug":"生活点滴","permalink":"https://allwens.work/categories/生活点滴/"}]},{"title":"RSSHub+Bot实现RSS订阅","slug":"yourRssBot","date":"2020-02-04T21:39:23.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"yourRssBot/","link":"","permalink":"https://allwens.work/yourRssBot/","excerpt":"最近开始使用RSS，真的是high到不行！定义什么是RSS？引用维基百科上的定义：RSS（简易信息聚合）是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含全文或是节录的文字，再加上发布者所订阅之网摘数据和授权的元数据。在这个信息碎片化的时代，兴趣算法大行其道，我们逐渐失去了自己选择信息的权力。如果你也像我一样对此感到厌倦，也许回归RSS会是个更好的选择。RSS能让你自由地订阅信息来源，可以避免无关信息的干扰，节省你宝贵的时间。","text":"最近开始使用RSS，真的是high到不行！定义什么是RSS？引用维基百科上的定义：RSS（简易信息聚合）是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含全文或是节录的文字，再加上发布者所订阅之网摘数据和授权的元数据。在这个信息碎片化的时代，兴趣算法大行其道，我们逐渐失去了自己选择信息的权力。如果你也像我一样对此感到厌倦，也许回归RSS会是个更好的选择。RSS能让你自由地订阅信息来源，可以避免无关信息的干扰，节省你宝贵的时间。使用使用RSS，你需要可订阅的源和RSS阅读器。订阅源很遗憾，现如今很多网站都没有对RSS提供支持，这里就要提到DIYgod大佬发起的项目RSSHub了。RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容。用户可以选择使用RSSHub官方的demo，或者选择自行部署，具体请参阅文档。阅读器同理，现如今优秀的RSS阅读器也如凤毛麟角，具体到linux平台更是少之又少，我试用了很多款都没有找到满意的。于是转变思路选择了telegram bot，原因主要有两点：可以多平台使用可以实时更新去查找相关教程，发现了go实现的flowerss-bot，同样支持使用demo或自行部署，但试用后发现其demo更新频率很低，于是转而手动部署（顺便还能利用上我的闲置服务器）。截图体验：订阅肺炎辟谣网站，还没听到谣言就收到了辟谣推送 (๑•̀ㅂ•́)و✧使用截图：","categories":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/便捷使用/"}],"tags":[{"name":"rss","slug":"rss","permalink":"https://allwens.work/tags/rss/"}],"keywords":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/便捷使用/"}]},{"title":"马原毛概刷题工具(WEB VERSION)","slug":"questionTest","date":"2020-01-30T09:44:08.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"questionTest/","link":"","permalink":"https://allwens.work/questionTest/","excerpt":"考试之前临时赶工做了个马原刷题工具，考试后有了时间顺便把它拓展成了马原毛概刷题工具，添加了随机刷题，考试模拟，错题本等功能，但平心而论，python的命令行程序还是不太易于使用，于是考虑将其改为网页版本，目前该项目已经开源在了github（在此前并没有接触过前端，所以可能会有很多不足之处）。","text":"考试之前临时赶工做了个马原刷题工具，考试后有了时间顺便把它拓展成了马原毛概刷题工具，添加了随机刷题，考试模拟，错题本等功能，但平心而论，python的命令行程序还是不太易于使用，于是考虑将其改为网页版本，目前该项目已经开源在了github（在此前并没有接触过前端，所以可能会有很多不足之处）。后端后端使用go的轻量web框架gin，代码在这儿！其通过读取当前目录的mayuan.json/maogai.json，根据不同的路由返回不同的结果：访问地址返回结果/:subject/position/:num返回该subject位置为num的题目/:subject/random/返回该subject随机一道题目/:subject/random/radio返回该subject随机一道单选题目/:subject/random/checkbox返回该subject随机一道多选题目前端前端使用vue.js，准备学习的时候，在官方文档中发现了这句话：官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。而我对前端知识一无所知，于是先去freecodecamp学习了HTML基础和前几节CSS（因为CSS内容实在是太多了！），然后去廖雪峰教程把JavaScript学到了函数部分，之后一边参考官方文档学习一边上手开发。首先使用webpack脚手架创建vue项目，接着安装并引入muse-ui组件库。路由import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; import index from &#39;../components/index&#39; import temp from &#39;../components/temp&#39; import exam from &#39;../components/exam&#39; import order from &#39;../components/order&#39; import about from &#39;../components/about&#39; Vue.use(Router) export default new Router({ routes: [ { path: &#39;/&#39;, name: &#39;index&#39;, component: index }, { path: &#39;/马原&#39;, name: &#39;mayuan&#39;, component: temp }, { path: &#39;/毛概&#39;, name: &#39;maogai&#39;, component: temp }, { path: &#39;/马原/顺序刷题&#39;, name: &#39;mayuanorder&#39;, component: order }, { path: &#39;/毛概/顺序刷题&#39;, name: &#39;maogaiorder&#39;, component: order }, { path: &#39;/马原/考试模拟&#39;, name: &#39;mayuanexam&#39;, component: exam }, { path: &#39;/毛概/考试模拟&#39;, name: &#39;maogaiexam&#39;, component: exam }, { path: &#39;/关于&#39;, name: &#39;about&#39;, component: about } ] }) 组件App.vue中写入通用的顶栏，侧边栏等内容，监听路由变化修改标题。index.vue和about.vue使用纯HTML/CSS写成。temp.vue用于选择刷题方式。order.vue为顺序刷题界面，使用mu-pagination进行翻页，exam.vue为考试模拟界面，使用mu-load-more实现题目部分加载。question.vue为单位题目，是order.vue和exam.vue的子组件，监听props中num的变化，调用getQuestion()加载相应题目并判断是单选还是多选。在选择选项时使用ifRight()判断答案是否正确。// ifRight ifRight: function () { let answer if (this.isRadio === false) {// 多选将答案array排序并链接为字符串 answer = this.yourAnswer.sort().join(&quot;&quot;) } else {// 单选直接获取 answer = this.yourAnswer } if (answer === this.question[&quot;Answer&quot;]) { this.isRight = true let that = this if (this.timer) clearTimeout(this.timer) this.timer = setTimeout(function () {// 显示2s的通知 that.isRight = false }, 2000) } else { this.isRight = false } } // getQuestion getQuestion () { this.yourAnswer=[] //根据父组件的path和当前num获取要请求的地址 if (this.type === &quot;/马原/顺序刷题&quot;) { this.url = &quot;https://.../api/mayuan/position/&quot; + (this.num - 1) } else if (this.type === &quot;/毛概/顺序刷题&quot;) { this.url = &quot;https://.../api/maogai/position/&quot; + (this.num - 1) } else if (this.type === &quot;/马原/考试模拟&quot;) { if (this.num &lt;= 40) { this.url = &quot;https://.../api/mayuan/random/radio&quot; } else { this.url= &quot;https://.../api/mayuan/random/checkbox&quot; } } else if (this.type === &quot;/毛概/考试模拟&quot;) { if (this.num &lt;= 40) { this.url = &quot;https://.../api/maogai/random/radio&quot; } else { this.url = &quot;https://.../api/maogai/random/checkbox&quot; } } axios// 使用axios请求api获取题目 .get(this.url) .then(response =&gt; { this.question = response.data if (this.question[&#39;Answer&#39;].length &gt; 1) {// 判断是单选还是多选 this.isRadio = false } else { this.isRadio = true } }) } 部署在部署的时候遇到了不少问题。开始在本地调试时发现无法加载出题目。查看chrome console中的错误信息，查询后发现是因为后端没有配置跨域，于是在后端路由中加上了：c.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) 调试正常，但部署到github pages后发现仍然无法加载，查看错误信息，得知在https网页中不能加载http资源，于是任务变成了给gin加上https。查阅发现一般方法是申请子域名和免费证书，但我懒得整那么多了，正好手头有个https域名，直接给nginx的当前server块配个反向代理：location /api{ proxy_pass http://localhost:8080; } 然后在github pages中请求这个地址，但是不知道是不是因为中间隔了个nginx，又出现了跨域问题，一时没有查到解决方法，所以不得已把前端也部署在了nginx上，问题解决（唯一问题是我的服务器没有备案，所以只能手动输入端口访问）。参考Vue.js官方文档Muse-UI官方文档Gin.README.md扶朕起来朕还能学","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://allwens.work/categories/开发记录/"}],"tags":[{"name":"website","slug":"website","permalink":"https://allwens.work/tags/website/"},{"name":"go","slug":"go","permalink":"https://allwens.work/tags/go/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://allwens.work/tags/Vue-js/"}],"keywords":[{"name":"开发记录","slug":"开发记录","permalink":"https://allwens.work/categories/开发记录/"}]},{"title":"本站更换主题啦！","slug":"changeTheme","date":"2020-01-29T22:29:44.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"changeTheme/","link":"","permalink":"https://allwens.work/changeTheme/","excerpt":"故事要从四天前说起…那天，我像往常一样刷着网站，偶然发现了DIYgod大佬的博客，看着这精美的主题，再回头审视一下自己使用的简陋到爆的next，不禁萌生了更换主题的想法。","text":"故事要从四天前说起…那天，我像往常一样刷着网站，偶然发现了DIYgod大佬的博客，看着这精美的主题，再回头审视一下自己使用的简陋到爆的next，不禁萌生了更换主题的想法。根据footer里的信息，我找到了这个主题Sagiri的托管地址，将其下载了下来，配置好_config.yml文件并hexo s，本以为事情就这样结束了。然并卵，我发现有很多功能都无法正常使用，正如他本人在这篇文章中写的一样：主题虽然开源了，但是属于自用性质的项目，很多应该做成可定制化的地方都没有做，从开源项目的视角来看做得并不好，而我目前又对制作主题并没有太高的兴致，所以使用之前还请慎重考虑然而这是后话了，当时的我并没有看到这些，于是头铁地开始了主题文件的增删改查之路（此处省略一万字）。四天过去了，通过对文件的深度剖析（指删除很多本来就有的模块然后重新添加），我深刻地了解了css、html和javascript，明白了hexo主题的组织形式（并没有），于是准备记录一下这个主题部分特性的实现方式：网页无刷新跳转/自动滚动到正文使用pjax实现，主要参考这篇文章。根据网页状态动态修改标题// cheat.js var OriginTitle = document.title; var titleTime; document.addEventListener(&#39;visibilitychange&#39;, function () { if (document.hidden) { $(&#39;[rel=&quot;icon&quot;]&#39;).attr(&#39;href&#39;, &quot;/images/failure.ico&quot;); document.title = &#39;╭(°A°`)╮ 页面崩溃啦 ~&#39;; clearTimeout(titleTime); } else { $(&#39;[rel=&quot;icon&quot;]&#39;).attr(&#39;href&#39;, &quot;/images/favicon.ico&quot;); document.title = &#39;(ฅ&gt;ω&lt;*ฅ) 噫又好了~&#39; + OriginTitle; titleTime = setTimeout(function () { document.title = OriginTitle; }, 2000); } }); 随机的丝带背景// evan-you.js /*&lt;canvas id=&quot;evanyou&quot;&gt;&lt;/canvas&gt;*/ if (document.getElementById(&#39;evanyou&#39;)) { var c = document.getElementById(&#39;evanyou&#39;), x = c.getContext(&#39;2d&#39;), pr = window.devicePixelRatio || 1, w = window.innerWidth, h = window.innerHeight, f = 90, q, m = Math, r = 0, u = m.PI * 2, v = m.cos, z = m.random c.width = w * pr c.height = h * pr x.scale(pr, pr) x.globalAlpha = 0.6 function evanyou () { x.clearRect(0, 0, w, h) q = [{ x: 0, y: h * .7 + f }, { x: 0, y: h * .7 - f }] while (q[1].x &lt; w + f) d(q[0], q[1]) } function d (i, j) { x.beginPath() x.moveTo(i.x, i.y) x.lineTo(j.x, j.y) var k = j.x + (z() * 2 - 0.25) * f, n = y(j.y) x.lineTo(k, n) x.closePath() r -= u / -50 x.fillStyle = &#39;#&#39; + (v(r) * 127 + 128 &lt;&lt; 16 | v(r + u / 3) * 127 + 128 &lt;&lt; 8 | v(r + u / 3 * 2) * 127 + 128).toString(16) x.fill() q[0] = q[1] q[1] = { x: k, y: n } } function y (p) { var t = p + (z() * 2 - 1.1) * f return (t &gt; h || t &lt; 0) ? y(p) : t } document.onclick = evanyou document.ontouchstart = evanyou evanyou() } 点击的烟花效果// fireworks.js class Circle { constructor({ origin, speed, color, angle, context }) { this.origin = origin this.position = { ...this.origin } this.color = color this.speed = speed this.angle = angle this.context = context this.renderCount = 0 } draw() { this.context.fillStyle = this.color this.context.beginPath() this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2) this.context.fill() } move() { this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3) this.renderCount++ } } class Boom { constructor ({ origin, context, circleCount = 16, area }) { this.origin = origin this.context = context this.circleCount = circleCount this.area = area this.stop = false this.circles = [] } randomArray(range) { const length = range.length const randomIndex = Math.floor(length * Math.random()) return range[randomIndex] } randomColor() { const range = [&#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;] return &#39;#&#39; + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) } randomRange(start, end) { return (end - start) * Math.random() + start } init() { for(let i = 0; i &lt; this.circleCount; i++) { const circle = new Circle({ context: this.context, origin: this.origin, color: this.randomColor(), angle: this.randomRange(Math.PI - 1, Math.PI + 1), speed: this.randomRange(1, 6) }) this.circles.push(circle) } } move() { this.circles.forEach((circle, index) =&gt; { if (circle.position.x &gt; this.area.width || circle.position.y &gt; this.area.height) { return this.circles.splice(index, 1) } circle.move() }) if (this.circles.length == 0) { this.stop = true } } draw() { this.circles.forEach(circle =&gt; circle.draw()) } } class CursorSpecialEffects { constructor() { this.computerCanvas = document.createElement(&#39;canvas&#39;) this.renderCanvas = document.createElement(&#39;canvas&#39;) this.computerContext = this.computerCanvas.getContext(&#39;2d&#39;) this.renderContext = this.renderCanvas.getContext(&#39;2d&#39;) this.globalWidth = window.innerWidth this.globalHeight = window.innerHeight this.booms = [] this.running = false } handleMouseDown(e) { const boom = new Boom({ origin: { x: e.clientX, y: e.clientY }, context: this.computerContext, area: { width: this.globalWidth, height: this.globalHeight } }) boom.init() this.booms.push(boom) this.running || this.run() } handlePageHide() { this.booms = [] this.running = false } init() { const style = this.renderCanvas.style style.position = &#39;fixed&#39; style.top = style.left = 0 style.zIndex = &#39;999999999999999999999999999999999999999999&#39; style.pointerEvents = &#39;none&#39; style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight document.body.append(this.renderCanvas) window.addEventListener(&#39;mousedown&#39;, this.handleMouseDown.bind(this)) window.addEventListener(&#39;pagehide&#39;, this.handlePageHide.bind(this)) } run() { this.running = true if (this.booms.length == 0) { return this.running = false } requestAnimationFrame(this.run.bind(this)) this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.booms.forEach((boom, index) =&gt; { if (boom.stop) { return this.booms.splice(index, 1) } boom.move() boom.draw() }) this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight) } } const cursorSpecialEffects = new CursorSpecialEffects() cursorSpecialEffects.init() 侧栏的固定使用affix实现，主要参考这篇文章。valine评论系统支持pjax参考这个issue。害，换个主题真的太难了，一年之内不打算再换了！好了，写完去睡觉啦 XD！2020.1.30 23:12:33全站由github迁移到coding，国内浏览速度得到大幅提升。（香港服务器就是香啊！）","categories":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/网站建设/"}],"tags":[{"name":"website","slug":"website","permalink":"https://allwens.work/tags/website/"}],"keywords":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/网站建设/"}]},{"title":"ManjaroWPS切换中文问题","slug":"wpsChangeLanguage","date":"2020-01-15T13:39:27.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"wpsChangeLanguage/","link":"","permalink":"https://allwens.work/wpsChangeLanguage/","excerpt":"wps在前几天更新之后，界面语言变成了英文，本来没有很太在意，觉得可能过几天更新就好了，但等了几天好像并没有更新的迹象，于是寻找方法进行修复…","text":"wps在前几天更新之后，界面语言变成了英文，本来没有很太在意，觉得可能过几天更新就好了，但等了几天好像并没有更新的迹象，于是寻找方法进行修复…首先打开AUR仓库，查看wps-office有关的包，发现了wps-office-cn查看其依赖，发现了wps-office-mui-zh-cn (optional) – zh_CN support for WPS Office得到修复方法，即手动安装语言包：yay -S wps-office-mui-zh-cn 重新打开wps，不出意外的话应该已经修复成功了（因为wps优先使用系统语言），如果没有成功的话，手动点击右上角的A图标，在里面选择中文语言包进行切换即可。","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://allwens.work/categories/问题解决/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"manjaro","slug":"manjaro","permalink":"https://allwens.work/tags/manjaro/"}],"keywords":[{"name":"问题解决","slug":"问题解决","permalink":"https://allwens.work/categories/问题解决/"}]},{"title":"python中文字符串居中问题","slug":"stringCenter","date":"2019-12-22T22:40:01.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"stringCenter/","link":"","permalink":"https://allwens.work/stringCenter/","excerpt":"最近在实现一个小功能的时候遇到了问题：字符串的居中输出。虽然python有内置的字符串方法string.center()，使字符串可以居中输出，但它并不能顺利地处理中文字符串，一直无法达到让中文字符串居中的效果。","text":"最近在实现一个小功能的时候遇到了问题：字符串的居中输出。虽然python有内置的字符串方法string.center()，使字符串可以居中输出，但它并不能顺利地处理中文字符串，一直无法达到让中文字符串居中的效果。后来我突然醒悟，是不是因为python字符串长度的问题？用以下代码测试：str1=&#39;哈哈哈&#39; str2=&#39;hhh&#39; print(len(str1),&#39;+&#39;,len(str2)) 输出结果居然是3+3，也就是说python将一个汉字/字母都记作一个字符，但其实它们的宽度并不相同。这样计算的话必然会导致无法正常居中，关键是要把汉字区别出来，于是我手动写了个居中函数：def strCenter(str, len): lst = list(str) length = 0 for item in lst: if item in string.printable: length += 1 else: length += 2 count = int((len - length) / 2) result = count * &#39; &#39; + str + count * &#39; &#39; return result 就可以正常居中啦！追加以下内容测试一下：a = &#39;哈a哈a哈a哈a&#39; b = &#39;12345678901234567890&#39; print(a.center(20)) print(b.center(20)) print(20 * &#39;-&#39;) print(strCenter(a, 20)) print(strCenter(b, 20)) 运行结果： 哈a哈a哈a哈a 12345678901234567890 -------------------- 哈a哈a哈a哈a 12345678901234567890 任务成功完成！","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://allwens.work/categories/问题解决/"}],"tags":[{"name":"python","slug":"python","permalink":"https://allwens.work/tags/python/"}],"keywords":[{"name":"问题解决","slug":"问题解决","permalink":"https://allwens.work/categories/问题解决/"}]},{"title":"php表单提交并自动发送邮件","slug":"formSubmit","date":"2019-10-29T21:41:34.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"formSubmit/","link":"","permalink":"https://allwens.work/formSubmit/","excerpt":"最近在html5up上淘了个主页模板，模板底有一个表单，今天在修改模板的时候，朋友提起可以配置表单实现提交表单时自动发送邮件通知，于是就萌生了这个想法，结果没想到一搞就是三四个小时（主要是因为网上的某些“教程”太坑人了！），所以记录一下配置过程给后来人参考。","text":"最近在html5up上淘了个主页模板，模板底有一个表单，今天在修改模板的时候，朋友提起可以配置表单实现提交表单时自动发送邮件通知，于是就萌生了这个想法，结果没想到一搞就是三四个小时（主要是因为网上的某些“教程”太坑人了！），所以记录一下配置过程给后来人参考。给服务器安装php,php-fpm作者使用的是ubuntu18.04，所以使用sudo apt-get install php sudo apt-get install php-fpm web服务器添加php支持作者使用的是nginx，为支持php需要修改一下配置文件，网上不少教程说要改nginx.conf，但我发现我这里的配置文件和他们的有很大差异，后来实测修改/etc/nginx/sites-available/default有效。将文件与php有关部分修改为： # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html index.php; server_name _; # nginx不允许静态文件响应post请求，会出现405 not allowed提示，所以需要添加以下内容 # 需要开启8080端口，或者可以修改为目前已经开启的端口（或许） error_page 405 =200 @405; location @405 { proxy_method GET; proxy_pass http://你的地址:8080; } location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; } # pass PHP scripts to FastCGI server # location ~ \\.php$ { include snippets/fastcgi-php.conf; # With php-fpm (or other unix sockets): # 这里需要把php7.2修改为安装php时显示的版本 fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; } 修改表单所在的html文件接下来打开表单所在的html文件，修改form标签，例如我的：&lt;!--其实粘贴这么多只是想说form标签需要加个action=&quot;mail.php&quot;啦（滑稽）--&gt; &lt;form method=&quot;post&quot; action=&quot;mail.php&quot;&gt; &lt;div class=&quot;fields&quot;&gt; &lt;div class=&quot;field half&quot;&gt; &lt;label for=&quot;name&quot;&gt;Name&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;field half&quot;&gt; &lt;label for=&quot;email&quot;&gt;Email&lt;/label&gt; &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;field&quot;&gt; &lt;label for=&quot;message&quot;&gt;Message&lt;/label&gt; &lt;textarea name=&quot;message&quot; id=&quot;message&quot; rows=&quot;6&quot;&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class=&quot;actions&quot;&gt; &lt;li&gt;&lt;input type=&quot;submit&quot; value=&quot;Send Message&quot; class=&quot;primary&quot; /&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=&quot;reset&quot; value=&quot;Clear&quot; /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/form&gt; 配置mail.php文件form提交将会调用mail.php文件，接下来就需要配置它了。我浏览了许多网站，发现网上大体只有两个模板，即这个和这个。但亲身体验后发现都！不！能！用！第一个是单纯的配置文件问题，我把各项修改好后还是不能用。（或许是因为我多删了点东西？）第二个则使用了php的mail()函数，不过很不幸的是，正如这篇最后解决我问题的文章中写的一样：PHP环境下，是提供了发送邮件的函数mail()的，不过该函数要求服务器支持sendmail或者必须设置一台不需要中继的邮件发送服务器，但现在要找到一台不需要身份验证的邮件发送中继几乎不可能，所以使用mail函数往往无法成功发送电子邮件。mail()函数确实无法成功发送邮件。这篇文章同样给出了一个解决办法，就是使用PHPMailer。将其git clone到服务器并解压，mail.php只需按照README.md中所给的Example进行微量修改，我的大概为：&lt;?php // Import PHPMailer classes into the global namespace // These must be at the top of your script, not inside a function use PHPMailer\\PHPMailer\\PHPMailer; use PHPMailer\\PHPMailer\\SMTP; use PHPMailer\\PHPMailer\\Exception; // 修改这三个文件的路径为服务器路径 require &#39;./PHPMailer/src/Exception.php&#39;; require &#39;./PHPMailer/src/PHPMailer.php&#39;; require &#39;./PHPMailer/src/SMTP.php&#39;; // 这里将内容对应改成form标签中各项的名字 $email=$_POST[&#39;email&#39;]; $name=$_POST[&#39;name&#39;]; $message=$_POST[&#39;message&#39;]; // Instantiation and passing `true` enables exceptions $mail = new PHPMailer(true); // 这里我使用的是qq邮箱，其它邮箱同理 try { //Server settings $mail-&gt;SMTPDebug = SMTP::DEBUG_SERVER; // Enable verbose debug output $mail-&gt;isSMTP(); // Send using SMTP $mail-&gt;Host = &#39;smtp.qq.com&#39;; // Set the SMTP server to send through $mail-&gt;SMTPAuth = true; // Enable SMTP authentication $mail-&gt;Username = &#39;邮箱的用户名&#39;; // SMTP username $mail-&gt;Password = &#39;邮箱的密码&#39;; // SMTP password // $mail-&gt;SMTPSecure = PHPMailer::ENCRYPTION_STARTTLS; // Enable TLS encryption; `PHPMailer::ENCRYPTION_SMTPS` also accepted $mail-&gt;SMTPSecure = &#39;ssl&#39;; $mail-&gt;Port = 465; // TCP port to connect to //Recipients $mail-&gt;setFrom(&#39;邮箱的用户名&#39;, &#39;随便填个昵称&#39;); $mail-&gt;addAddress(&#39;发送到的邮箱&#39;, &#39;随便填个昵称&#39;); // Add a recipient // 后边的那些我不用，就注释掉了 // $mail-&gt;addAddress(&#39;ellen@example.com&#39;); // Name is optional // $mail-&gt;addReplyTo(&#39;info@example.com&#39;, &#39;Information&#39;); // $mail-&gt;addCC(&#39;cc@example.com&#39;); // $mail-&gt;addBCC(&#39;bcc@example.com&#39;); // Attachments // $mail-&gt;addAttachment(&#39;/var/tmp/file.tar.gz&#39;); // Add attachments // $mail-&gt;addAttachment(&#39;/tmp/image.jpg&#39;, &#39;new.jpg&#39;); // Optional name // Content $mail-&gt;isHTML(true); // Set email format to HTML $mail-&gt;Subject = &quot;An E-mail from $email&quot;; $mail-&gt;Body = &quot;This e-mail is written by $name : $message&quot;; // 我在测试时，AltBody中的内容并不会在邮件中显示出来，目前暂时不清楚有什么用 $mail-&gt;AltBody = &quot;&quot;; $mail-&gt;send(); echo &#39;Message has been sent&#39;; } catch (Exception $e) { echo &quot;Message could not be sent. Mailer Error: {$mail-&gt;ErrorInfo}&quot;; } 提交不跳转方法经过以上配置之后，你的表单应该可以正常发送邮件了，唯一的不足是在点击提交之后会跳转出现一堆提示信息，影响观感，这篇文章中给出了一种可行方法，即为form标签加入target属性并添加iframe标签。以我的表单为例，需要将form标签修改为：&lt;form method=&quot;post&quot; action=&quot;mail.php&quot; target=&quot;id_iframe&quot;&gt; 并在其后添加：&lt;iframe id=&quot;id_iframe&quot; name=&quot;id_iframe&quot; style=&quot;&quot;&gt;&lt;/iframe&gt; 这样修改虽然有效，但会在点击提交之后出现一个简陋的框体，其中显示的内容就是之前跳转后的提示信息。这没有达到我们的目的，于是想到将iframe标签隐藏，也就是将其的高度和宽度设置为0：&lt;iframe id=&quot;id_iframe&quot; name=&quot;id_iframe&quot; style=&quot;&quot; width=&quot;0&quot; height=&quot;0&quot;&gt;&lt;/iframe&gt; 可这样又会出现一个问题，点击按钮之后邮件到底有没有发送成功是未知的，因为所有的提示信息都被隐藏掉了，那该怎么办呢？我想到的是，将原来php文件中的两个用于输出提示信息的echo修改成echo &quot;&lt;script&gt;alert(&#39;内容&#39;)&lt;/script&gt;&quot;，也就是：echo &#39;Message has been sent&#39;; // 替换为 echo &quot;&lt;script&gt;alert(&#39;Message has been sent&#39;)&lt;/script&gt;&quot;; echo &quot;Message could not be sent. Mailer Error: {$mail-&gt;ErrorInfo}&quot;; // 替换为 echo &quot;&lt;script&gt;alert(&#39;Message could not be sent.&#39;)&lt;/script&gt;&quot;; 这样的话就可以实现网页弹窗提示邮件发送结果而不跳转了。效果预览结语总体来说，以上实现方式虽然可以正常使用，但是还有很大改进空间，比如提交不跳转的实现方式。不过毕竟自己没有系统学习过web方面的知识，也只能得过且过了。等什么时候能闲下来再考虑改进吧（笑）。也欢迎大家在评论里给我提建议吖！（话说这篇文章真的有人看吗？！）","categories":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/网站建设/"}],"tags":[{"name":"website","slug":"website","permalink":"https://allwens.work/tags/website/"},{"name":"php","slug":"php","permalink":"https://allwens.work/tags/php/"}],"keywords":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/网站建设/"}]},{"title":"manjaro常用的垃圾清理命令","slug":"cleanUpFiles","date":"2019-08-12T15:17:25.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"cleanUpFiles/","link":"","permalink":"https://allwens.work/cleanUpFiles/","excerpt":"清除系统中无用的包sudo pacman -R $(pacman -Qdtq) 清除已下载的安装包","text":"清除系统中无用的包sudo pacman -R $(pacman -Qdtq) 清除已下载的安装包sudo pacman -Scc 日志垃圾查看日志文件du -t 100M /var or journalctl --disk-usage 删除指定大小日志文件sudo journalctl --vacuum-size=50M","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/系统优化/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"manjaro","slug":"manjaro","permalink":"https://allwens.work/tags/manjaro/"}],"keywords":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/系统优化/"}]},{"title":"禁用笔记本自带键盘的方法","slug":"disableKeyboard","date":"2019-07-03T12:13:55.000Z","updated":"2020-10-11T02:35:42.719Z","comments":true,"path":"disableKeyboard/","link":"","permalink":"https://allwens.work/disableKeyboard/","excerpt":"Windows禁用用管理员权限运行cmd，在其中输入：sc config i8042prt start= disabled 之后重启即可。","text":"Windows禁用用管理员权限运行cmd，在其中输入：sc config i8042prt start= disabled 之后重启即可。恢复与禁用的步骤相同，把输入的命令改为：sc config i8042prt start= demand Linux注意：manjaro需要使用sudo pacman -S xorg-xinput 进行安装以使用xinput命令。打开终端，输入xinput --list获取设备列表：❯ xinput --list ⎡ Virtual core pointer id=2 [master pointer (3)] ⎜ ↳ Virtual core XTEST pointer id=4 [slave pointer (2)] ⎜ ↳ USB Optical Mouse Mouse id=14 [slave pointer (2)] ⎜ ↳ Synaptics TM3253-001 id=11 [slave pointer (2)] ⎣ Virtual core keyboard id=3 [master keyboard (2)] ↳ Virtual core XTEST keyboard id=5 [slave keyboard (3)] ↳ Power Button id=6 [slave keyboard (3)] ↳ Video Bus id=7 [slave keyboard (3)] ↳ Power Button id=8 [slave keyboard (3)] ↳ Sleep Button id=9 [slave keyboard (3)] ↳ Integrated_Webcam_HD: Integrate id=10 [slave keyboard (3)] ↳ Dell WMI hotkeys id=12 [slave keyboard (3)] ↳ AT Translated Set 2 keyboard id=13 [slave keyboard (3)] ↳ DELL Wireless hotkeys id=15 [slave keyboard (3)] ↳ USB Keyboard Consumer Control id=16 [slave keyboard (3)] ↳ USB Keyboard System Control id=17 [slave keyboard (3)] ↳ USB Keyboard id=18 [slave keyboard (3)] 找到AT Translated Set 2 keyboard对应的id（本机为13）。禁用在终端中输入xinput set-prop 13 &quot;Device Enabled&quot; 0 恢复在终端中输入xinput set-prop 13 &quot;Device Enabled&quot; 1","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/系统优化/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"windows","slug":"windows","permalink":"https://allwens.work/tags/windows/"}],"keywords":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/系统优化/"}]}]}