{"meta":{"title":"JeasonLau's Blog","subtitle":null,"description":null,"author":"JeasonLau","url":"https://allwens.work","root":"/"},"pages":[{"title":"categories","date":"2019-07-03T03:49:06.000Z","updated":"2019-07-03T03:52:00.000Z","comments":false,"path":"categories/index.html","permalink":"https://allwens.work/categories/index.html","excerpt":"","text":""},{"title":"投喂通道","date":"2019-07-03T03:49:06.000Z","updated":"2020-01-26T15:25:56.000Z","comments":true,"path":"donate/index.html","permalink":"https://allwens.work/donate/index.html","excerpt":"","text":"预感到这又是一个没有人会看的界面 XD 想要投喂的看官们，可以在任意一篇文章下点击赞赏按钮，就可以看到alipay/wechatpay的收款码啦！"},{"title":"友情链接","date":"2019-07-03T03:49:06.000Z","updated":"2020-05-23T16:59:14.000Z","comments":true,"path":"friends/index.html","permalink":"https://allwens.work/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-03T03:49:23.000Z","updated":"2019-07-03T03:52:42.000Z","comments":false,"path":"tags/index.html","permalink":"https://allwens.work/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-07-03T03:49:06.000Z","updated":"2020-01-26T15:26:48.000Z","comments":true,"path":"message/index.html","permalink":"https://allwens.work/message/index.html","excerpt":"","text":"这是一个莫得感情的充数留言板（并不觉得有人会给我留言啊喂！ (๑•̀ㅂ•́)و✧ 大家有什么话想对我说可以在此留言哦，我如果看到一定会回复的！"}],"posts":[{"title":"arch系发行版安装windows字体","slug":"windowsFontForArchlinux","date":"2020-06-24T10:41:55.000Z","updated":"2020-06-25T04:44:52.708Z","comments":true,"path":"windowsFontForArchlinux/","link":"","permalink":"https://allwens.work/windowsFontForArchlinux/","excerpt":"背景日常生活中，总是会有一些奇奇怪怪的需求需要使用到office。对linux用户来说，虽然可以用wps代替ms office办公套件，但还会面临一个很大的问题：没有windows的字体库！ 试想一下，作业要求提交使用微软雅黑字体的word文档，而linux上根本没有这个字体，你要怎么办？打开老师做的ppt课件，结果因为缺少字体而处处错位，又要怎么办？… 无数次面临这种问题之后，我萌生了安装windows字体的想法。","text":"背景日常生活中，总是会有一些奇奇怪怪的需求需要使用到office。对linux用户来说，虽然可以用wps代替ms office办公套件，但还会面临一个很大的问题：没有windows的字体库！ 试想一下，作业要求提交使用微软雅黑字体的word文档，而linux上根本没有这个字体，你要怎么办？打开老师做的ppt课件，结果因为缺少字体而处处错位，又要怎么办？… 无数次面临这种问题之后，我萌生了安装windows字体的想法。 注：本文记录了整个打包流程，如果想要直接获取打包好的软件包，请点击此处。 安装查了查，网上的解决方法大部分是把windows的字体目录挂载过来，然而像我这种linux单系统用户肯定就不能这么操作了XD 于是，我打开了万能的arch wiki，根据指引来到了ttf-ms-win10的aur界面，在安装前首先看一下作者的置顶评论： FAQ, please read before posting: I get an error that the sources cannot be downloaded: Please read the instructions on the top of the PKGBUILD. Some fonts are missing in my copy of Windows (e.g., holomdl2, corbel, chandra, …): It seems that Microsoft distributes some fonts only with some Windows versions. You can just comment out the corresponding line in the PKGBUILD and then build with “makepkg –skipchecksums”. Some fonts have different checksums: We keep the checksums synchronized with our own Windows installations that are regularly updated. Different Windows versions, different ISOs etc. may contain fonts in different versions/variants. Just build the package using “makepkg –skipchecksums”. Why does the version not correspond to the latest Windows 10 build: If fonts have not changes between builds, there is no reason to change the version number of this package. Why are some fonts (e.g., traditional chinese, japanese etc.) not included here, not even in the corresponding split packages: We currently only include fonts that are installed on a standard Windows installation, without additional feature-on-demand packages (see: https://docs.microsoft.com/en-us/typography/fonts/windows_10_font_list). 嗯嗯..说的已经很明白啦，接着就先克隆一下项目： 12git clone https://aur.archlinux.org/ttf-ms-win10.gitcd ttf-ms-win10 听他的，先看一下PKGBUILD： 1vim PKGBUILD 首先是一段版权声明，在windows系统以外的地方使用Microsoft fonts是违法的。 估计是为了避免法律问题，它并没有自带windows的字体，而是给出了两种方法： 从当前已有的windows系统获取（如果有的话我就直接挂载了啊喂！） 从windows的安装包中提取 所以就按着他的步骤来吧： 到这里下载windows10安装包 打开iso镜像，解压出sources/install.wim 安装wimlib并解压wim格式 123sudo pacman -S wimlib# 切换到install.wim所在的目录wimextract install.wim 1 /Windows/&#123;Fonts/\"*\".&#123;ttf,ttc&#125;,System32/Licenses/neutral/\"*\"/\"*\"/license.rtf&#125; --dest-dir fonts 将解压出的字体全都放到PKGBUILD所在目录，执行： 1makepkg 不出所料，果然出现了他说的第三点问题，不同windows版本可能会含有同一字体的不同版本，导致哈希值检验出错，脚本检验失败自动退出。 解决办法也像他说的，只需要跳过检验就好了： 1makepkg –skipchecksums 经过漫长的等待，应该已经打包了很多种语言的包出来，接着只需要： 1sudo pacman -U ./ttf-ms-win10-zh_cn-version.pkg.tar.xz 就成功啦！ 下载我已经把我打包好的包放在了网盘里，可以点击此处下载。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"manjaro","slug":"manjaro","permalink":"https://allwens.work/tags/manjaro/"}]},{"title":"medum-一款命令行待办事项管理器","slug":"medum","date":"2020-05-23T15:09:29.000Z","updated":"2020-05-23T16:41:38.000Z","comments":true,"path":"medum/","link":"","permalink":"https://allwens.work/medum/","excerpt":"前几天整了一个命令行待办事项管理器：medum。注意到自己已经有一阵子没发过文章了，正好今晚有空，把它拿出来随便聊聊，顺便水一篇233（（ 名称由来这个项目叫做medum，为什么呢？ 因为它的开发目的是防止我忘记ddl，所以从一开始，它就是作为一个备忘录（memorandum）而被设计的。我从memorandum这个单词中取了前两个和后三个字母进行拼接，于是medum诞生了。（好随意啊XD","text":"前几天整了一个命令行待办事项管理器：medum。注意到自己已经有一阵子没发过文章了，正好今晚有空，把它拿出来随便聊聊，顺便水一篇233（（ 名称由来这个项目叫做medum，为什么呢？ 因为它的开发目的是防止我忘记ddl，所以从一开始，它就是作为一个备忘录（memorandum）而被设计的。我从memorandum这个单词中取了前两个和后三个字母进行拼接，于是medum诞生了。（好随意啊XD 代码结构具体的开发初衷已经写在了README.md里，所以接下来就说说代码结构吧。 下面是所有的代码文件： 1234567891011121314.├── config│ └── config.go├── main.go├── output│ └── output.go├── path│ └── path.go├── public│ └── public.go├── sqlite│ └── sqlite.go└── text └── text.go 每个模块的功能如下： path.go：负责获取配置文件夹路径，配置文件路径和sqlite数据库路径。 config.go：负责读取配置文件，并在配置文件不存在的情况下写入默认配置。 public.go：存放公共的结构体，包括在多个文件进行引用的Configuration（配置文件）、Event（事项）。 sqlite.go：sqlite数据库的打开，插入，更新，查询，删除功能的实现。 text.go：存放该程序近乎所有的文本信息（包括报错、提醒以及sql语句）。 output.go：将配置文件的颜色映射为函数，对彩色输出函数的反射调用进行一层封装。 设计思路 首先从功能出发，既然要读取文件，那么获取路径是必须的，于是首先考虑实现path.go： 12345678910// path.gofunc GetPath() string &#123; //获取文件夹路径，路径为~/.medum path, err := homedir.Dir() if err != nil &#123; fmt.Printf(text.HomedirError, err) os.Exit(1) &#125; return filepath.Join(path, \".medum\")&#125;// 后面获取配置文件和数据的路径很简单，在文件夹路径后加文件名就可以 有了路径，接下来就是要到路径中读取文件啦，但文件读入到哪儿呢？为了让内容有处可去，应该先实现一个配置文件的结构体。考虑到配置文件自定义的是颜色，必定需要被输出模块读取，所以将其分离放在public.go里，接着再写config.go： 123456// public.gotype Configuration struct &#123; NumberColor string EventColor string TimeColor string&#125; 123456789101112131415161718192021222324252627282930313233// config.gofunc ReadConfig() *public.Configuration &#123; configPath := path.GetConfigPath() // 检测配置文件是否存在，不存在则写入默认配置 if _, err := os.Stat(configPath); err != nil &amp;&amp; !os.IsExist(err) &#123; writeInitConfig(configPath) &#125; // ... decoder := json.NewDecoder(file) conf := new(public.Configuration) // 将文件读取到conf中 err = decoder.Decode(conf) // ... return conf func writeInitConfig(configPath string) &#123; // 首先看文件夹是否存在，如果不存在则新建 tmp := path.GetPath() if _, err := os.Stat(tmp); !os.IsExist(err) &#123; os.Mkdir(tmp, os.FileMode(0777)) &#125; // 接着新建配置文件 file, err := os.Create(configPath) // 创建默认配置 conf := public.Configuration&#123; NumberColor: \"red\", EventColor: \"blue\", TimeColor: \"yellow\", &#125; // 写入 encoder := json.NewEncoder(file) encoder.Encode(conf)&#125; 实现了配置文件的读取，紧接着就是数据的操作了，考虑实现sqlite.go，但为了方便修改，尽量将所有的文本内容与逻辑分离，需要先写text.go，但在这之前，还要先考虑好事件结构体的内容，所以最终顺序是public.go-&gt;text.go-&gt;sqlite.go： 123456789// public.go// 包括id，事件内容，开始结束日期，当前状态type Event struct &#123; ID int EventContent string BeginDate int64 EndDate int64 IsEnd uint8&#125; 1234567891011121314151617181920212223242526// text.goconst ( // 创建表，其中id自增，event为事件名，开始日期结束日期用时间戳存储。 // 状态标记方面，一个事件应该有未开始，正在进行，结束三个状态，故isEnd可取0,1,2，对应三种状态 CreateTable = `create table if not exists eventList( id integer primary key autoincrement, event varchar(100) not null, beginDate unsigned bigint not null, endDate unsigned bigint not null, isEnd smallint default 1 not null );` // 插入一行 InsertRow = `insert into eventList (event,beginDate,endDate) values (?,?,?);` // 当前时间大于结束时间则标记超时 MarkOutdate = `update eventList set isEnd=2 where ?&gt;endDate;` // 当前时间小于开始时间则标记未开始 MarkNotStart = `update eventList set isEnd=0 where ?&lt;beginDate;` // 介于开始结束之间标记正在进行 MarkInProgress = `update eventList set isEnd=1 where ? between beginDate and endDate;` // 得到所有的事件，按事件状态，结束日期排序 QueryRow = `select * from eventList order by isEnd desc,endDate` // 删除超时事件 DeleteOutDate = `delete from eventList where isEnd=2` // 对于完成了的事件，通过id删除 DeleteID = `delete from eventList where id=?`) 123456789101112131415161718192021// sqlite.go// 打开数据库func openSqliteDB() *sql.DB &#123; db, err := sql.Open(\"sqlite3\", path.GetDataPath()) if err != nil &#123; fmt.Printf(text.OpenDBError, err) os.Exit(1) &#125; db.Exec(text.CreateTable) return db&#125;// 剩余函数逻辑类似，取其中之一举例：func InsertSqliteDB(eventContent string, beginDate, endDate time.Time) error &#123; // 打开数据库 db := openSqliteDB() // 结束时关闭 defer db.Close() // 执行语句 _, err := db.Exec(text.InsertRow, eventContent, beginDate.Unix(), endDate.Unix()) return err&#125; 接下来考虑实现output.go： 12345678910111213141516171819202122232425262728293031323334// output.go// 支持的所有颜色（采用map[string]interface&#123;&#125;存储）var funcs = map[string]interface&#123;&#125;&#123; \"red\": color.New(color.FgRed), \"blue\": color.New(color.FgBlue), \"cyan\": color.New(color.FgCyan), \"green\": color.New(color.FgGreen), \"yellow\": color.New(color.FgYellow), \"magenta\": color.New(color.FgMagenta), \"white\": color.New(color.FgWhite), \"black\": color.New(color.FgBlack), \"hired\": color.New(color.FgHiRed), \"hiblue\": color.New(color.FgHiBlue), \"hicyan\": color.New(color.FgHiCyan), \"higreen\": color.New(color.FgHiGreen), \"hiyellow\": color.New(color.FgHiYellow), \"himagenta\": color.New(color.FgHiMagenta), \"hiwhite\": color.New(color.FgHiWhite), \"hiblack\": color.New(color.FgHiBlack),&#125;// 使用reflect包进行动态调用func call(m map[string]interface&#123;&#125;, color string, params ...interface&#123;&#125;) &#123; function := reflect.ValueOf(m[color]).MethodByName(\"Printf\") in := make([]reflect.Value, len(params)) for index, param := range params &#123; in[index] = reflect.ValueOf(param) &#125; function.Call(in)&#125;// 将call进行一层封装，对外公开Call函数func Call(color string, params ...interface&#123;&#125;) &#123; call(funcs, color, params...)&#125; 万事俱备，最后只需要在主函数中完成调用逻辑即可（当然还需要补全一些错误输出、给用户的提示等等，不过那些已经很简单了）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125// main.go// 接受的命令行参数var ( begin string end string name string remove bool done int)func main() &#123; app := &amp;cli.App&#123; // 省略掉参数绑定等流程 Action: func(c *cli.Context) error &#123; // 读取配置文件 conf := *config.ReadConfig() if remove &#123; // -r：首先标记过期事件，接着删除之 sqlite.UpdateSqliteDB(text.MarkOutdate) err := sqlite.DeleteOutDate() if err != nil &#123; fmt.Printf(text.DeleteOutdateError, err) os.Exit(1) &#125; fmt.Println(text.DeleteOutdateSuccess) &#125; else if done != 0 &#123; // -d int： 直接删除该id err := sqlite.DeleteID(done) if err != nil &#123; fmt.Printf(text.DeleteIDError, err) os.Exit(1) &#125; fmt.Println(text.DeleteIDSuccess) &#125; else &#123; if len(end) == 0 &#123; // 如果没有-d，打印事件列表 // 这里只标记进行中和超时，是因为在插入事件时已经标记了是否未开始，时间顺序流动，不可能从开始变为未开始 sqlite.UpdateSqliteDB(text.MarkInProgress) sqlite.UpdateSqliteDB(text.MarkOutdate) // ...省略输出部分 &#125; &#125; else &#123; // 如果存在-e，则解析结束时间，开始事件如果有就解析，没有默认为当前时间 var beginTime, endTime time.Time endTime = handleString(end) if len(begin) == 0 &#123; beginTime = time.Now() &#125; else &#123; beginTime = handleString(begin) &#125; if beginTime.Unix() &gt;= endTime.Unix() &#123; fmt.Println(text.TimeError) os.Exit(1) &#125; // 将输入事件插入 err := sqlite.InsertSqliteDB(name, beginTime, endTime) if err != nil &#123; fmt.Printf(text.InsertDBError, err) &#125; // 标记未开始 sqlite.UpdateSqliteDB(text.MarkNotStart) fmt.Println(text.InsertSuccess) &#125; &#125; return nil &#125;&#125; err := app.Run(os.Args) if err != nil &#123; log.Fatal(err) &#125;&#125;func handleString(tm string) time.Time &#123; // 时间字符串转time.Time，只接受month.day.hour.minute格式 tmp := strings.Split(tm, \".\") // 长度不为4则退出 if len(tmp) != 4 &#123; fmt.Println(text.LengthError) os.Exit(1) &#125; else &#123; // 补全0，例如将5.20.12.0补全为05.20.12.00，防止解析错误 for index := range tmp &#123; if len(tmp[index]) == 1 &#123; tmp[index] = \"0\" + tmp[index] &#125; &#125; stdString := fmt.Sprintf(text.MyTime, strconv.Itoa(time.Now().Year()), tmp[0], tmp[1], tmp[2], tmp[3]) result, err := time.ParseInLocation(text.StandardTime, stdString, time.Now().Local().Location()) if err != nil &#123; fmt.Printf(text.ParamError, err) os.Exit(1) &#125; return result &#125; //useless line, just to prevent warning return time.Now()&#125;func formatTime(begin, end int64, IsEnd uint8) string &#123; // 将时间转换成%s time remaining/%s time beginning格式，其中的%s调用下面的formatTimeString函数获取 now := time.Now() if IsEnd == 0 &#123; beginTime := time.Unix(begin, 0) dur := beginTime.Sub(now) return fmt.Sprintf(text.TimeBeginning, formatTimeString(dur.Minutes())) &#125; else if IsEnd == 1 &#123; endTime := time.Unix(end, 0) dur := endTime.Sub(now) return fmt.Sprintf(text.TimeRemaining, formatTimeString(dur.Minutes())) &#125; else &#123; return fmt.Sprintf(text.TimeRemaining, \"no time\") &#125;&#125;func formatTimeString(min float64) string &#123; // 获取天/小时/分钟 var tmp string if min &gt; 1440 &#123; tmp = strconv.Itoa(int(min/1440)) + \" days\" &#125; else if min &gt; 60 &#123; tmp = strconv.Itoa(int((min / 60))) + \" hours\" &#125; else &#123; tmp = strconv.Itoa(int(min)) + \" minutes\" &#125; return tmp&#125; 这样下来，预想的功能就实现的差不多了，任务成功完成。 结束语okk，这样就结束啦，算是写了个小总结吧。 代码基本全程都有注释（不过为了符合golang的规范，使用的是塑料英语XD），觉得自己代码写的还是蛮易读的，欢迎大家阅读给出建议哦！","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://allwens.work/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"go","slug":"go","permalink":"https://allwens.work/tags/go/"}]},{"title":"为typora集成sm.ms图床，纵享丝滑体验","slug":"typora","date":"2020-04-28T12:01:51.000Z","updated":"2020-04-29T03:11:54.000Z","comments":true,"path":"typora/","link":"","permalink":"https://allwens.work/typora/","excerpt":"起因是安利一位同学使用typora写markdown，他那里上官网比较慢，所以我去帮他下载，闲来无聊顺便逛了逛。逛完才发现，原来typora有那么多自定义选项！（没错我这一年多一直用的默认设置XD） 以此为契机，我第一次打开了它的偏好设置，查看了各类选项， 发现里面有一个很有意思的功能：插入图片自动上传，觉得挺方便的，于是准备配置一波… 注意：笔者使用的是linux，windows请酌情参考（安装方法和配置文件路径会略有差异）","text":"起因是安利一位同学使用typora写markdown，他那里上官网比较慢，所以我去帮他下载，闲来无聊顺便逛了逛。逛完才发现，原来typora有那么多自定义选项！（没错我这一年多一直用的默认设置XD） 以此为契机，我第一次打开了它的偏好设置，查看了各类选项， 发现里面有一个很有意思的功能：插入图片自动上传，觉得挺方便的，于是准备配置一波… 注意：笔者使用的是linux，windows请酌情参考（安装方法和配置文件路径会略有差异） 安装typora中可选的上传配置有Picgo，Picgo-core，custom command和none，本人很久前用过Picgo，但其使用electron构建的UI在linux上体验属实很差，所以此处我选用了命令行版的Picgo-core。 首先进行安装： 123npm install picgo -g# oryarn global add picgo 插件配置 注意：windows用户请确保将picgo添加到环境变量，否则需要把下文中的所有picgo替换为path+picgo（例：C:\\picgo\\picgo.exe） Picgo本身支持多种图床上传，我选用的是方便免费的SM.MS，于项目主页我们了解到： PicGo 本体支持如下图床： SM.MS v1.5.1 由于官方不再支持V1版本，暂时请使用smms-user插件 也就是说我们需要额外安装插件才可以正常使用SM.MS图床进行上传，于是打开terminal，执行： 1picgo install smms-user 安装成功后，我们仍然需要对其进行配置。执行以下命令： 12picgo config plugin smms-user? Auth 你需要在此处输入你的TOKEN，首先到SM.MS网站注册一个账户，接着访问该链接获取TOKEN并输入，你应该会收到以下提示信息： 1[PicGo SUCCESS]: Configure config successfully! 接下来是最后一步，你需要把你使用的uploader修改为smms-user，在命令行中执行： 12345678910picgo config uploader? Choose a(n) uploader (Use arrow keys)❯ smms-user smms tcyun github qiniu imgur aliyun (Move up and down to reveal more choices) 移动箭头并选中smms-user，点击回车，此时你位于~/.picgo/config.json的配置文件内容应该形如： 12345678910111213141516&#123; \"picBed\": &#123; \"current\": \"smms-user\", \"uploader\": \"smms-user\", \"transformer\": \"path\", \"smms-user\": &#123; \"Authorization\": \"your token\" &#125; &#125;, \"picgoPlugins\": &#123; \"picgo-plugin-smms-user\": true &#125;, \"picgo-plugin-smms-user\": &#123; \"Authorization\": \"your token\" &#125;&#125; 图片上传服务配置成功完成！ typora集成配置完上传服务，接下来在typora对接一下即可。 打开typora偏好设置，在上传服务设定栏选custom command（这里解释一下，选择Picgo-core只能使用其规定的路径，我们自己指定路径还是需要用custom command），然后在下面的文本框输入： 1picgo upload 对接完成！接下来可以尝试点击旁边的“验证图片上传选项”按钮，测试上传是否成功了。 小提示目前仅支持把文件拖动到typora中完成上传，如果直接从剪切板粘贴，typora会自动将该图片放到~/upload文件夹下但不会自动上传，需要自己手动点击“上传图片”。这是typora本身的bug： This should be a bug, there’s no need to create the “upload” folder. 详见#3331. 参考 Picgo Picgo-core picgo-plugin-smms-user Picgo-core document","categories":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/%E4%BE%BF%E6%8D%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"image","slug":"image","permalink":"https://allwens.work/tags/image/"}]},{"title":"配置世纪互联版onedrive，实现网络共享文件夹","slug":"configOnedrive","date":"2020-03-03T14:00:24.000Z","updated":"2020-06-01T14:42:42.000Z","comments":true,"path":"configOnedrive/","link":"","permalink":"https://allwens.work/configOnedrive/","excerpt":"var ap = new APlayer({ element: document.getElementById(\"aplayer-trSHNvPE\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"삐삐\", author: \"IU\", url: \"https://alphaone-my.sharepoint.cn/personal/jeasonlau_vip_tg/_layouts/15/download.aspx?SourceUrl=%2Fpersonal%2Fjeasonlau%5Fvip%5Ftg%2FDocuments%2F%E9%9F%B3%E4%B9%90%2FIU%2F%EC%82%90%EC%82%90%2FIU%20%2D%20%EC%82%90%EC%82%90%2Eflac\", pic: \"https://ae01.alicdn.com/kf/Ua6b1c96ff42c499c9751865c0d0b3795e.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 背景很久之前就想有一个网络共享文件夹，即一个既能在本地当做普通文件夹使用，也能通过互联网访问到的文件夹。 大致对比了一下这些可能能够用于实现该功能的服务： 服务 优点 缺点 以百度云为代表的国内网盘 存储空间大 对linux支持差，访问速度慢 google drive/mega等国外网盘 linux客户端支持 存储空间较小，国内速度慢甚至无法连通 各类oss服务（例：阿里云oss） 官方挂载支持，速度无限制 存储费用、流量费用、请求费用累计，代价昂贵 服务器空闲存储空间 可通过sftp访问 受服务器带宽限制，使用效果并不理想","text":"var ap = new APlayer({ element: document.getElementById(\"aplayer-trSHNvPE\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"삐삐\", author: \"IU\", url: \"https://alphaone-my.sharepoint.cn/personal/jeasonlau_vip_tg/_layouts/15/download.aspx?SourceUrl=%2Fpersonal%2Fjeasonlau%5Fvip%5Ftg%2FDocuments%2F%E9%9F%B3%E4%B9%90%2FIU%2F%EC%82%90%EC%82%90%2FIU%20%2D%20%EC%82%90%EC%82%90%2Eflac\", pic: \"https://ae01.alicdn.com/kf/Ua6b1c96ff42c499c9751865c0d0b3795e.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 背景很久之前就想有一个网络共享文件夹，即一个既能在本地当做普通文件夹使用，也能通过互联网访问到的文件夹。 大致对比了一下这些可能能够用于实现该功能的服务： 服务 优点 缺点 以百度云为代表的国内网盘 存储空间大 对linux支持差，访问速度慢 google drive/mega等国外网盘 linux客户端支持 存储空间较小，国内速度慢甚至无法连通 各类oss服务（例：阿里云oss） 官方挂载支持，速度无限制 存储费用、流量费用、请求费用累计，代价昂贵 服务器空闲存储空间 可通过sftp访问 受服务器带宽限制，使用效果并不理想 可以看到各个服务各有优缺点。但最近，我发现了另一款产品：世纪互联版onedrive。它是微软委托国内的世纪互联运营的，对比onedrive国际版，一方面其数据中心位于北京/上海，极大地优化了国内用户的访问速度；另一方面，淘宝有大量低价号贩售，五六十块即可买到“永久”的5T存储空间（此处存疑）。上网查询，发现这个世纪互联版onedrive在本地可以通过魔改rclone实现挂载，在云端可以使用魔改oneindex、zfile等开源项目实现浏览器访问（不走服务器流量，无限速），完美满足我的需求，于是入了一个，准备开搞。 需要 一台自己的电脑 一台服务器 开放api的世纪互联版onedrive账号（一定要是开放api的！） 云端先说简单的云端访问，我使用的是zfile（因为它配置简单，原生支持世纪互联onedrive）。 接下来操作以ubuntu为例，centos请移步官方文档。 ssh到服务器，首先安装依赖： 1sudo apt install -y openjdk-8-jre-headless unzip 下载项目，解压并给予可执行权限： 1234cd ~wget https://c.jun6.net/ZFILE/zfile-release.warmkdir zfile &amp;&amp; unzip zfile-release.war -d zfile &amp;&amp; rm -rf zfile-release.warchmod +x zfile/bin/*.sh 启动项目： 1~/zfile/bin/start.sh 接下来访问http://你的公网ip:8080/#/install进行配置。其中的访问令牌和刷新令牌需要访问这个网址登录账号后获取，填写成功之后点击确认即配置完成，可以在网页访问到你的onedrive云盘了！ 本地接下来配置稍微复杂点儿的本地挂载。 以下内容转载自znov的博客，因为他是在服务器挂载，而我是在本机，所以做了少量修改。(windows只需要进行前三步，未经过实测)。 世纪互联 OneDrive 获取 CLIENT_ID 及 CLIENT_SECRET 打开该网页登录账号。 左侧找到Azure Active Directory点击左侧找到 应用注册 点击上方找到 新注册 点击名称：onedrive受支持的账户类型：任何组织目录（第二个）重定向 URL：http://localhost:53682点击注册找到 应用程序(客户端) ID 复制保存左侧找到 证书和密码 点击下方 客户端密码 - 新建客户端密码说明：onedrive截止期限：默认 一年内点击 添加，值复制保存左侧找到 API 权限 点击添加权限：Microsoft Graph - 委托的权限：全部勾选（这里经我测试只勾选File栏即可） 安装配置rclone 此处下载rclone世纪互联版 该文件来源于全球主机论坛爱纯粹大佬，因为原博客的下载链接速度很慢，所以另存了一份。希望大家下载的同时可以顺便去原博客评论支持一下！ linux在当前目录打开terminal，执行 12sudo mv ./rclone的文件名 /usr/bin/rclonesudo chmod +x /usr/bin/rclone windows请自行查阅如何将文件添加到环境变量中。 注：此步骤非必须，如未执行则将以下语句的rclone改为rclone的路径形式。 输入rclone config进行如下配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127e) Edit existing remoten) New remoted) Delete remoter) Rename remotec) Copy remotes) Set configuration passwordq) Quit confige/n/d/r/c/s/q&gt; nname&gt;onedriveType of storage to configure.Enter a string value. Press Enter for the default (\"\").Choose a number from below, or type in your own value 1 / 1Fichier \\ \"fichier\" 2 / Alias for an existing remote \\ \"alias\" 3 / Amazon Drive \\ \"amazon cloud drive\" 4 / Amazon S3 Compliant Storage Provider (AWS, Alibaba, Ceph, Digital Ocean, Dreamhost, IBM COS, Minio, etc) \\ \"s3\" 5 / Backblaze B2 \\ \"b2\" 6 / Box \\ \"box\" 7 / Cache a remote \\ \"cache\" 8 / Citrix Sharefile \\ \"sharefile\" 9 / Dropbox \\ \"dropbox\"10 / Encrypt/Decrypt a remote \\ \"crypt\"11 / FTP Connection \\ \"ftp\"12 / Google Cloud Storage (this is not Google Drive) \\ \"google cloud storage\"13 / Google Drive \\ \"drive\"14 / Google Photos \\ \"google photos\"15 / Hubic \\ \"hubic\"16 / JottaCloud \\ \"jottacloud\"17 / Koofr \\ \"koofr\"18 / Local Disk \\ \"local\"19 / Mail.ru Cloud \\ \"mailru\"20 / Mega \\ \"mega\"21 / Microsoft Azure Blob Storage \\ \"azureblob\"22 / Microsoft OneDrive \\ \"onedrive\"23 / OpenDrive \\ \"opendrive\"24 / Openstack Swift (Rackspace Cloud Files, Memset Memstore, OVH) \\ \"swift\"25 / Pcloud \\ \"pcloud\"26 / Put.io \\ \"putio\"27 / QingCloud Object Storage \\ \"qingstor\"28 / SSH/SFTP Connection \\ \"sftp\"29 / Transparently chunk/split large files \\ \"chunker\"30 / Union merges the contents of several remotes \\ \"union\"31 / Webdav \\ \"webdav\"32 / Yandex Disk \\ \"yandex\"33 / http Connection \\ \"http\"34 / premiumize.me \\ \"premiumizeme\"Storage&gt;22** See help for onedrive backend at: https://rclone.org/onedrive/ **Microsoft App Client IdLeave blank normally.Enter a string value. Press Enter for the default (\"\").client_id&gt;输入上面“应用程序（客户端）id”Microsoft App Client SecretLeave blank normally.Enter a string value. Press Enter for the default (\"\").client_secret&gt;输入上面申请到的“值”OneDrive operated by 21Vianet (世纪互联).Enter a boolean value (true or false). Press Enter for the default (\"false\").is_21vianet_version&gt;trueEdit advanced config? (y/n)y) Yesn) Noy/n&gt;nUse auto config? * Say Y if not sure * Say N if you are working on a remote or headless machiney) Yesn) Noy/n&gt;y之后会自动打开一个网页，在这个网页里进行登录，然后继续..Choose a number from below, or type in an existing value 1 / OneDrive Personal or Business \\ \"onedrive\" 2 / Root Sharepoint site \\ \"sharepoint\" 3 / Type in driveID \\ \"driveid\" 4 / Type in SiteID \\ \"siteid\" 5 / Search a Sharepoint site \\ \"search\"Your choice&gt; 1Found 1 drives, please select the one you want to use:0: OneDrive (business) id=******Chose drive to use:&gt;0Found drive 'root' of type 'business', URL: https://alphaone-my.sharepoint.cn/personal/***Is that okay?y) Yesn) Noy/n&gt;yyq 进行挂载 linux需要安装fuse，各大发行版不一样就不详述了，我的manjaro自带。 命令如下：（其中的/表示需要挂载到本地的onedrive路径，/mnt/表示本机的挂载路径，可对应修改） 12345挂载命令：rclone mount onedrive:/ /mnt/ --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000后台挂载命令：nohup rclone mount onedrive:/ /mnt --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000 &gt;/dev/null 2&gt;&amp;1 &amp;卸载命令：fusermount -qzu LocalFolder onedrive 使用挂载脚本 这个挂载脚本能够实现基本的挂载、卸载和重新挂载功能，之后使用的话就没有必要输入那么长的命令了。脚本如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#!/bin/bash# ------------------------------------------PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin:~/binexport PATH### BEGIN INIT INFO# Provides: rclone# Required-Start: $all# Required-Stop: $all# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: Start rclone at boot time# Description: Enable rclone by daemon.### END INIT INFO# ------------------------------------------# 以上两条横线之间的内容不自启的话可以去掉（个人觉得自启的话去掉应该也没啥影响）NAME_BIN=\"rclone\"NAME=\"onedrive\"REMOTE='/' #需要挂载到本地的onedrive路径，可修改LOCAL='/mnt/' #挂载到本地的哪个文件夹，可修改Green_font_prefix=\"\\033[32m\" &amp;&amp; Red_font_prefix=\"\\033[31m\" &amp;&amp; Green_background_prefix=\"\\033[42;37m\" &amp;&amp; Red_background_prefix=\"\\033[41;37m\" &amp;&amp; Font_color_suffix=\"\\033[0m\"Info=\"$&#123;Green_font_prefix&#125;[信息]$&#123;Font_color_suffix&#125;\"Error=\"$&#123;Red_font_prefix&#125;[错误]$&#123;Font_color_suffix&#125;\"RETVAL=0check_running()&#123; PID=\"$(ps -C $NAME_BIN -o pid= |head -n1 |grep -o '[0-9]\\&#123;1,\\&#125;')\" if [[ ! -z $&#123;PID&#125; ]]; then return 0 else return 1 fi&#125;do_start()&#123; check_running if [[ $? -eq 0 ]]; then echo -e \"$&#123;Info&#125; $NAME_BIN (PID $&#123;PID&#125;) 正在运行...\" &amp;&amp; exit 0 else fusermount -zuq $LOCAL &gt;/dev/null 2&gt;&amp;1 mkdir -p $LOCAL /usr/bin/rclone mount $NAME:$REMOTE $LOCAL --copy-links --no-gzip-encoding --no-check-certificate --allow-other --allow-non-empty --umask 000 &gt;/dev/null 2&gt;&amp;1 &amp; check_running if [[ $? -eq 0 ]]; then echo -e \"$&#123;Info&#125; $NAME_BIN 启动成功 !\" else echo -e \"$&#123;Error&#125; $NAME_BIN 启动失败 !\" fi fi&#125;do_stop()&#123; check_running if [[ $? -eq 0 ]]; then kill -9 $&#123;PID&#125; RETVAL=$? if [[ $RETVAL -eq 0 ]]; then echo -e \"$&#123;Info&#125; $NAME_BIN 停止成功 !\" else echo -e \"$&#123;Error&#125; $NAME_BIN 停止失败 !\" fi else echo -e \"$&#123;Info&#125; $NAME_BIN 未运行\" RETVAL=1 fi fusermount -zuq $LOCAL &gt;/dev/null 2&gt;&amp;1 fusermount -zuq $LOCAL1 &gt;/dev/null 2&gt;&amp;1&#125;do_status()&#123; check_running if [[ $? -eq 0 ]]; then echo -e \"$&#123;Info&#125; $NAME_BIN (PID $(echo $&#123;PID&#125;)) 正在运行...\" else echo -e \"$&#123;Info&#125; $NAME_BIN 未运行 !\" RETVAL=1 fi&#125;do_restart()&#123; do_stop do_start&#125;case \"$1\" in start|stop|restart|status) do_$1 ;; *) echo \"使用方法: $0 &#123; start | stop | restart | status &#125;\" RETVAL=1 ;;esacexit $RETVAL 假设该脚本被保存为rcloned，首先给予可执行权限： 1chmod +x rcloned的路径 之后可以选择将其移动到环境变量中，使用的时候手动执行rcloned start： 123sudo mv rcloned的路径 /usr/bin/rcloned# 每次使用时rcloned start 也可以选择像原文那样设置为开机自动运行（可能不支持所有发行版）： 12sudo mv rcloned的路径 /etc/init.d/rclonedsudo /etc/init.d/rcloned start 截图 碎碎念本来打算稍微写写水一篇文章的，没想到一不小心写了这么多… 中间某些步骤写的过分详细了，希望大家阅读的时候不要嫌我啰嗦 orz 参考 zfile官方文档 znov的博客 Zephyr 杂货铺（我购买账号的地方）","categories":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/%E4%BE%BF%E6%8D%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"onedrive","slug":"onedrive","permalink":"https://allwens.work/tags/onedrive/"}]},{"title":"从oh my zsh到oh my fish","slug":"zshToFish","date":"2020-02-29T13:32:44.000Z","updated":"2020-02-29T14:49:20.000Z","comments":true,"path":"zshToFish/","link":"","permalink":"https://allwens.work/zshToFish/","excerpt":"为什么今天连发两篇文章呢？大概是想纪念一下四年一度的2.29吧（笑 起因众所周知，shell有很多种，其中最常用的有bash和zsh，而oh my zsh是基于zsh的一个拓展工具集，自从接触linux，我一直在使用zsh &amp; oh my zsh。它易用，易拓展，但也有一个很大的缺点：太！慢！了！","text":"为什么今天连发两篇文章呢？大概是想纪念一下四年一度的2.29吧（笑 起因众所周知，shell有很多种，其中最常用的有bash和zsh，而oh my zsh是基于zsh的一个拓展工具集，自从接触linux，我一直在使用zsh &amp; oh my zsh。它易用，易拓展，但也有一个很大的缺点：太！慢！了！ 想象你需要打开terminal切换到blog路径，运行terminal的瞬间，你开始输入命令，你希望看到的结果： 123456~⟩ j blog/home/jeasonlau/File/blog~/File/blog⟩ 但实际的结果却是： 123456j ~⟩ blogunknown command : blog~⟩ 惊不惊喜？意不意外？ 在多次遭遇这种状况后，我实在无法忍受，开始了更换shell之路… 更换曾经也听说过另一款著名的shell：fish。在NEU lug群里吐槽zsh慢的时候，意外发现几位群友都在使用fish，于是决定更换。 搜索fish文档，发现arch系发行版可以直接安装，于是 1sudo pacman -S fish 安装成功之后，使用 1chsh -s /usr/local/bin/fish 将默认shell更换为fish。体验一番后感觉确实比zsh快了不少，同时原生支持命令高亮、命令建议等功能，不需要自己去手动配置，可以说是开箱即用了。 主题更换成功之后，更重要的任务是换主题！秉持着(命令行不花里胡哨怎么行！)的基本原则，我开始搜索fish的主题推荐，虽然没有找到什么结果，但让我发现了另一个东西：oh my fish。 它是一个类似oh my zsh的，对fish shell进行拓展的工具，具体来说包括插件和主题，于是参考文档进行安装： 1curl -L https://get.oh-my.fish | fish 安装完成之后就可以在available themes里进行挑选啦，找到心仪的主题后只需要执行 1omf install &lt;theme name&gt; 即可成功安装。 把全部主题看了一遍，顺便做一下主题推荐吧。 我个人喜欢的有四款： pure（慎用） 该主题是我在zsh上使用的主题，也被移植到了fish上，但试用后发现其兼容并不好，总会出一些奇奇怪怪的问题，但因为日久生情，还是将其排在第一位吧。 clearance 另一款极简主题，实际使用效果和pure相差不多，只是截图显得比较丑。 tomita 截图很好看，但默认颜色与截图有部分不同，同时因为鱼标的颜色默认为浅黄，对亮色背景不够友好。（当然也可以自行修改配置文件来修改颜色） nai 如果上面的是极简，这个就是极度极简，但麻雀虽小五脏俱全，简简单单反而有种别样的魅力。","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"manjaro","slug":"manjaro","permalink":"https://allwens.work/tags/manjaro/"}]},{"title":"一个简单的命令行图床上传工具","slug":"uploadImage","date":"2020-02-29T05:37:06.000Z","updated":"2020-02-29T09:49:18.000Z","comments":true,"path":"uploadImage/","link":"","permalink":"https://allwens.work/uploadImage/","excerpt":"昨天使用缩狗图床api写了个命令行图床上传工具，支持指定使用的图床，支持单文件/多文件/多目录（非递归）上传。虽然代码很简单，但还是准备记录一下（因为想水篇文章XD","text":"昨天使用缩狗图床api写了个命令行图床上传工具，支持指定使用的图床，支持单文件/多文件/多目录（非递归）上传。虽然代码很简单，但还是准备记录一下（因为想水篇文章XD 获取api既然要使用api，当然要获取api啦，首先看一下网站源码（此处只摘录了有用部分）： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!--图床的选择--&gt;&lt;div class=\"bodyer\"&gt; &lt;label&gt;&lt;input name=\"keke\" checked=\"checked\" type=\"radio\" value=\"1688\"&gt;阿里图床&lt;/label&gt; &lt;label&gt;&lt;input name=\"keke\" type=\"radio\" value=\"tieba\"&gt;百度图床&lt;/label&gt; &lt;label&gt;&lt;input name=\"keke\" type=\"radio\" value=\"360\"&gt;360图床&lt;/label&gt; &lt;label&gt;&lt;input name=\"keke\" type=\"radio\" value=\"taobao\"&gt;淘宝图床&lt;/label&gt; &lt;label&gt;&lt;input name=\"keke\" type=\"radio\" value=\"smms\"&gt;SM.MS图床&lt;/label&gt; &lt;label&gt;&lt;input name=\"keke\" type=\"radio\" value=\"sohu\"&gt;搜狐图床&lt;/label&gt; &lt;label&gt;&lt;input name=\"keke\" type=\"radio\" value=\"jd\"&gt;京东图床&lt;/label&gt;&lt;/div&gt;&lt;!--图片的上传--&gt;&lt;script&gt; var imagesUpload = function (files) &#123; a = $('input:radio:checked').val(); $(files).each(function (key, value) &#123; setTimeout(function () &#123; uurrll = 'https://pic.suo.dog/api/tc.php?type=' + a + '&amp;echo=imgurl' image_form = new FormData(); image_form.append(\"file\", value); $.ajax(&#123; url: uurrll, type: 'POST', data: image_form, contentType: false, cache: false, processData: false, async: false, success: function (data) &#123; if (typeof (data) == 'string') &#123; imgurl = data &#125; else &#123; imgurl = data.imgurl &#125; &#125;, error: function (XMLResponse) &#123; alert(\"error:\" + XMLResponse.responseText); &#125; &#125;); &#125;, 100); &#125;) &#125;;&lt;/script&gt; 上面的代码还是很清楚的，用选择器获取当前选中radio的value，使用其拼接需要请求的api，接着用ajax将文件数据post到api，成功后返回图片的地址。 开始编写有了api，接下来就很简单了，基本思路就是： 打开文件 使用requests进行post 输出返回的图片url 使用了requests/click/os三个包。缺少的包可以使用sudo pip install 包名安装。 首先将允许的图片文件拓展名和api地址设置为全局变量： 123# 这里列举了几种常见的图片格式，其它格式可以修改后自行测试allowedExtension = ['.jpeg', '.bmp', '.jpg', '.png', '.webp']url = '' 接着使用click为main函数增加命令行参数： 123@click.command()@click.option('--type', '-t', default='1688', type=click.Choice(['1688', 'tieba', '360', 'taobao', 'smms', 'sohu', 'jd']), help='image hosting service.')@click.argument('paths', nargs=-1, type=click.Path(exists=True, readable=True)) --type/-t option用于指定使用的图床，限制了图床的选择范围，默认使用阿里图床，paths argument接受多个路径参数，在此处保证了目录存在并可读。 然后是main函数： 12345678910111213141516def main(type, paths): global url url = 'https://pic.suo.dog/api/tc.php?type=&#123;&#125;&amp;echo=imgurl'.format(type) count = 0 print('\\033[33m开始上传...\\033[0m') for path in paths: if os.path.isdir(path): if not path.endswith('/'): path += '/' items = os.listdir(path) for item in items: if os.path.isfile(path + item): count += uploadFile(path + item) else: count += uploadFile(path) print('\\033[33m上传完成，共上传&#123;&#125;张图片!\\033[0m'.format(count)) 类似于\\033[33m开始上传...\\033[0m的格式是为了实现彩色输出，详情见该文章。 使用获取到的type组成url，使用count标记上传图片的张数，遍历所有的路径参数，如果该路径参数为目录，则尝试上传该目录的所有文件，如果该路径参数为文件，则直接尝试上传该文件。最后输出上传的图片张数。 之后是核心的上传函数： 123456789def uploadFile(file): if os.path.splitext(file)[-1] in allowedExtension: postContent = &#123;'file': open(file, 'rb')&#125; with requests.post(url, files=postContent) as response: print('\\033[31m&#123;&#125;\\033[0m : \\033[4;32m&#123;&#125;\\033[0m'.format( os.path.basename(file), response.text)) return 1 else: return 0 判断拓展名是否允许，如果允许则将该文件用二进制打开，post给api，输出文件名和上传的地址，返回1，否则返回0。 最后的内容就不用说了： 12if __name__ == '__main__': main() 使用截图 该截图同样使用该工具上传（使用阿里图床/--type 1688） 结语啊，没想到这么几行代码居然能水这么长一篇文章！（滑稽 目前1688图床可以正常使用，其它图床没有测试，如果有什么问题的话可以反馈给我。","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://allwens.work/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"python","slug":"python","permalink":"https://allwens.work/tags/python/"},{"name":"image","slug":"image","permalink":"https://allwens.work/tags/image/"}]},{"title":"大二下学期即将开始啦！","slug":"newTerm","date":"2020-02-23T08:52:32.000Z","updated":"2020-03-02T10:58:48.000Z","comments":true,"path":"newTerm/","link":"","permalink":"https://allwens.work/newTerm/","excerpt":"又是好长一段时间过去了！ 这些天因为病毒侵袭一直宅在家里。浑浑噩噩地度过了难熬的寒假，总算是盼来了新学期！（不是","text":"又是好长一段时间过去了！ 这些天因为病毒侵袭一直宅在家里。浑浑噩噩地度过了难熬的寒假，总算是盼来了新学期！（不是 课表说到新学期，第一想到的当然是新课表啦。下面是我的课表： 授课因为病毒的影响，前几周只能老老实实在家里上网课了。大概就是这些，目前还有几门课没有通知，先不管啦… 科目 授课方式 具体内容 备注 人工智能 MOOC+BB+QQ群 参见BB平台 无 数字逻辑与数字系统 雨课堂直播+MOOC+BB+QQ群 参见BB平台 需要提前安装Altera Quartus 13.1或更高版本 算法设计与分析 未知 无 无 汇编语言程序设计 BB+QQ群 参见BB平台 记得按时提交作业（平时成绩50分，作业占很大比例） 编译原理 未知 无 无 形势与政策 优课堂 无 作业要写2000字时事评论（纸版），返校后上交 思想政治理论实践课 未知 无 无 体育（羽毛球） MOOC+体适能训练 无 MOOC为《八法五步拳》 最后明天就要上课了，就目前来看，网课属实不大方便。一方面老师需要花费额外时间熟悉平台使用，另一方面，学生们需要时刻关注这些平台，平台过于分散也给学生们带来了很大的困扰。 希望疫情快快结束，大家能尽快回归到自己的日常生活吧。","categories":[{"name":"生活点滴","slug":"生活点滴","permalink":"https://allwens.work/categories/%E7%94%9F%E6%B4%BB%E7%82%B9%E6%BB%B4/"}],"tags":[{"name":"study","slug":"study","permalink":"https://allwens.work/tags/study/"}]},{"title":"RSSHub+Bot实现RSS订阅","slug":"yourRssBot","date":"2020-02-04T13:39:23.000Z","updated":"2020-02-23T16:37:16.000Z","comments":true,"path":"yourRssBot/","link":"","permalink":"https://allwens.work/yourRssBot/","excerpt":"最近开始使用RSS，真的是high到不行！ 定义什么是RSS？引用维基百科上的定义： RSS（简易信息聚合）是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含全文或是节录的文字，再加上发布者所订阅之网摘数据和授权的元数据。 在这个信息碎片化的时代，兴趣算法大行其道，我们逐渐失去了自己选择信息的权力。如果你也像我一样对此感到厌倦，也许回归RSS会是个更好的选择。RSS能让你自由地订阅信息来源，可以避免无关信息的干扰，节省你宝贵的时间。","text":"最近开始使用RSS，真的是high到不行！ 定义什么是RSS？引用维基百科上的定义： RSS（简易信息聚合）是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含全文或是节录的文字，再加上发布者所订阅之网摘数据和授权的元数据。 在这个信息碎片化的时代，兴趣算法大行其道，我们逐渐失去了自己选择信息的权力。如果你也像我一样对此感到厌倦，也许回归RSS会是个更好的选择。RSS能让你自由地订阅信息来源，可以避免无关信息的干扰，节省你宝贵的时间。 使用使用RSS，你需要可订阅的源和RSS阅读器。 订阅源 很遗憾，现如今很多网站都没有对RSS提供支持，这里就要提到DIYgod大佬发起的项目RSSHub了。 RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容。 用户可以选择使用RSSHub官方的demo，或者选择自行部署，具体请参阅文档。 阅读器 同理，现如今优秀的RSS阅读器也如凤毛麟角，具体到linux平台更是少之又少，我试用了很多款都没有找到满意的。于是转变思路选择了telegram bot，原因主要有两点： 可以多平台使用 可以实时更新 去查找相关教程，发现了go实现的flowerss-bot，同样支持使用demo或自行部署，但试用后发现其demo更新频率很低，于是转而手动部署（顺便还能利用上我的闲置服务器）。 截图 体验：订阅肺炎辟谣网站，还没听到谣言就收到了辟谣推送 (๑•̀ㅂ•́)و✧ 使用截图：","categories":[{"name":"便捷使用","slug":"便捷使用","permalink":"https://allwens.work/categories/%E4%BE%BF%E6%8D%B7%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"rss","slug":"rss","permalink":"https://allwens.work/tags/rss/"}]},{"title":"马原毛概刷题工具(WEB VERSION)","slug":"questionTest","date":"2020-01-30T01:44:08.000Z","updated":"2020-02-04T13:44:28.000Z","comments":true,"path":"questionTest/","link":"","permalink":"https://allwens.work/questionTest/","excerpt":"考试之前临时赶工做了个马原刷题工具，考试后有了时间顺便把它拓展成了马原毛概刷题工具，添加了随机刷题，考试模拟，错题本等功能，但平心而论，python的命令行程序还是不太易于使用，于是考虑将其改为网页版本，目前该项目已经开源在了github（在此前并没有接触过前端，所以可能会有很多不足之处）。","text":"考试之前临时赶工做了个马原刷题工具，考试后有了时间顺便把它拓展成了马原毛概刷题工具，添加了随机刷题，考试模拟，错题本等功能，但平心而论，python的命令行程序还是不太易于使用，于是考虑将其改为网页版本，目前该项目已经开源在了github（在此前并没有接触过前端，所以可能会有很多不足之处）。 后端后端使用go的轻量web框架gin，代码在这儿！ 其通过读取当前目录的mayuan.json/maogai.json，根据不同的路由返回不同的结果： 访问地址 返回结果 /:subject/position/:num 返回该subject位置为num的题目 /:subject/random/ 返回该subject随机一道题目 /:subject/random/radio 返回该subject随机一道单选题目 /:subject/random/checkbox 返回该subject随机一道多选题目 前端前端使用vue.js，准备学习的时候，在官方文档中发现了这句话： 官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。 而我对前端知识一无所知，于是先去freecodecamp学习了HTML基础和前几节CSS（因为CSS内容实在是太多了！），然后去廖雪峰教程把JavaScript学到了函数部分，之后一边参考官方文档学习一边上手开发。 首先使用webpack脚手架创建vue项目，接着安装并引入muse-ui组件库。 路由 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import Vue from 'vue'import Router from 'vue-router'import index from '../components/index'import temp from '../components/temp'import exam from '../components/exam'import order from '../components/order'import about from '../components/about'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'index', component: index &#125;, &#123; path: '/马原', name: 'mayuan', component: temp &#125;, &#123; path: '/毛概', name: 'maogai', component: temp &#125;, &#123; path: '/马原/顺序刷题', name: 'mayuanorder', component: order &#125;, &#123; path: '/毛概/顺序刷题', name: 'maogaiorder', component: order &#125;, &#123; path: '/马原/考试模拟', name: 'mayuanexam', component: exam &#125;, &#123; path: '/毛概/考试模拟', name: 'maogaiexam', component: exam &#125;, &#123; path: '/关于', name: 'about', component: about &#125; ]&#125;) 组件 App.vue中写入通用的顶栏，侧边栏等内容，监听路由变化修改标题。 index.vue和about.vue使用纯HTML/CSS写成。 temp.vue用于选择刷题方式。 order.vue为顺序刷题界面，使用mu-pagination进行翻页，exam.vue为考试模拟界面，使用mu-load-more实现题目部分加载。 question.vue为单位题目，是order.vue和exam.vue的子组件，监听props中num的变化，调用getQuestion()加载相应题目并判断是单选还是多选。在选择选项时使用ifRight()判断答案是否正确。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// ifRightifRight: function () &#123; let answer if (this.isRadio === false) &#123;// 多选将答案array排序并链接为字符串 answer = this.yourAnswer.sort().join(\"\") &#125; else &#123;// 单选直接获取 answer = this.yourAnswer &#125; if (answer === this.question[\"Answer\"]) &#123; this.isRight = true let that = this if (this.timer) clearTimeout(this.timer) this.timer = setTimeout(function () &#123;// 显示2s的通知 that.isRight = false &#125;, 2000) &#125; else &#123; this.isRight = false &#125; &#125;// getQuestiongetQuestion () &#123; this.yourAnswer=[] //根据父组件的path和当前num获取要请求的地址 if (this.type === \"/马原/顺序刷题\") &#123; this.url = \"https://.../api/mayuan/position/\" + (this.num - 1) &#125; else if (this.type === \"/毛概/顺序刷题\") &#123; this.url = \"https://.../api/maogai/position/\" + (this.num - 1) &#125; else if (this.type === \"/马原/考试模拟\") &#123; if (this.num &lt;= 40) &#123; this.url = \"https://.../api/mayuan/random/radio\" &#125; else &#123; this.url= \"https://.../api/mayuan/random/checkbox\" &#125; &#125; else if (this.type === \"/毛概/考试模拟\") &#123; if (this.num &lt;= 40) &#123; this.url = \"https://.../api/maogai/random/radio\" &#125; else &#123; this.url = \"https://.../api/maogai/random/checkbox\" &#125; &#125; axios// 使用axios请求api获取题目 .get(this.url) .then(response =&gt; &#123; this.question = response.data if (this.question['Answer'].length &gt; 1) &#123;// 判断是单选还是多选 this.isRadio = false &#125; else &#123; this.isRadio = true &#125; &#125;)&#125; 部署在部署的时候遇到了不少问题。 开始在本地调试时发现无法加载出题目。查看chrome console中的错误信息，查询后发现是因为后端没有配置跨域，于是在后端路由中加上了： 1c.Writer.Header().Set(\"Access-Control-Allow-Origin\", \"*\") 调试正常，但部署到github pages后发现仍然无法加载，查看错误信息，得知在https网页中不能加载http资源，于是任务变成了给gin加上https。 查阅发现一般方法是申请子域名和免费证书，但我懒得整那么多了，正好手头有个https域名，直接给nginx的当前server块配个反向代理： 123location /api&#123; proxy_pass http://localhost:8080;&#125; 然后在github pages中请求这个地址，但是不知道是不是因为中间隔了个nginx，又出现了跨域问题，一时没有查到解决方法，所以不得已把前端也部署在了nginx上，问题解决（唯一问题是我的服务器没有备案，所以只能手动输入端口访问）。 参考 Vue.js官方文档 Muse-UI官方文档 Gin.README.md 扶朕起来朕还能学","categories":[{"name":"开发记录","slug":"开发记录","permalink":"https://allwens.work/categories/%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"website","slug":"website","permalink":"https://allwens.work/tags/website/"},{"name":"go","slug":"go","permalink":"https://allwens.work/tags/go/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://allwens.work/tags/Vue-js/"}]},{"title":"本站更换主题啦！","slug":"changeTheme","date":"2020-01-29T14:29:44.000Z","updated":"2020-02-28T04:05:16.000Z","comments":true,"path":"changeTheme/","link":"","permalink":"https://allwens.work/changeTheme/","excerpt":"故事要从四天前说起… 那天，我像往常一样刷着网站，偶然发现了DIYgod大佬的博客，看着这精美的主题，再回头审视一下自己使用的简陋到爆的next，不禁萌生了更换主题的想法。","text":"故事要从四天前说起… 那天，我像往常一样刷着网站，偶然发现了DIYgod大佬的博客，看着这精美的主题，再回头审视一下自己使用的简陋到爆的next，不禁萌生了更换主题的想法。 根据footer里的信息，我找到了这个主题Sagiri的托管地址，将其下载了下来，配置好_config.yml文件并hexo s，本以为事情就这样结束了。然并卵，我发现有很多功能都无法正常使用，正如他本人在这篇文章中写的一样： 主题虽然开源了，但是属于自用性质的项目，很多应该做成可定制化的地方都没有做，从开源项目的视角来看做得并不好，而我目前又对制作主题并没有太高的兴致，所以使用之前还请慎重考虑 然而这是后话了，当时的我并没有看到这些，于是头铁地开始了主题文件的增删改查之路（此处省略一万字）。 四天过去了，通过对文件的深度剖析（指删除很多本来就有的模块然后重新添加），我深刻地了解了css、html和javascript，明白了hexo主题的组织形式（并没有），于是准备记录一下这个主题部分特性的实现方式： 网页无刷新跳转/自动滚动到正文 使用pjax实现，主要参考这篇文章。 根据网页状态动态修改标题 1234567891011121314151617// cheat.jsvar OriginTitle = document.title;var titleTime;document.addEventListener('visibilitychange', function () &#123; if (document.hidden) &#123; $('[rel=\"icon\"]').attr('href', \"/images/failure.ico\"); document.title = '╭(°A°`)╮ 页面崩溃啦 ~'; clearTimeout(titleTime); &#125; else &#123; $('[rel=\"icon\"]').attr('href', \"/images/favicon.ico\"); document.title = '(ฅ&gt;ω&lt;*ฅ) 噫又好了~' + OriginTitle; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125;&#125;); 随机的丝带背景 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// evan-you.js/*&lt;canvas id=\"evanyou\"&gt;&lt;/canvas&gt;*/if (document.getElementById('evanyou')) &#123; var c = document.getElementById('evanyou'), x = c.getContext('2d'), pr = window.devicePixelRatio || 1, w = window.innerWidth, h = window.innerHeight, f = 90, q, m = Math, r = 0, u = m.PI * 2, v = m.cos, z = m.random c.width = w * pr c.height = h * pr x.scale(pr, pr) x.globalAlpha = 0.6 function evanyou () &#123; x.clearRect(0, 0, w, h) q = [&#123; x: 0, y: h * .7 + f &#125;, &#123; x: 0, y: h * .7 - f &#125;] while (q[1].x &lt; w + f) d(q[0], q[1]) &#125; function d (i, j) &#123; x.beginPath() x.moveTo(i.x, i.y) x.lineTo(j.x, j.y) var k = j.x + (z() * 2 - 0.25) * f, n = y(j.y) x.lineTo(k, n) x.closePath() r -= u / -50 x.fillStyle = '#' + (v(r) * 127 + 128 &lt;&lt; 16 | v(r + u / 3) * 127 + 128 &lt;&lt; 8 | v(r + u / 3 * 2) * 127 + 128).toString(16) x.fill() q[0] = q[1] q[1] = &#123; x: k, y: n &#125; &#125; function y (p) &#123; var t = p + (z() * 2 - 1.1) * f return (t &gt; h || t &lt; 0) ? y(p) : t &#125; document.onclick = evanyou document.ontouchstart = evanyou evanyou()&#125; 点击的烟花效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155// fireworks.jsclass Circle &#123; constructor(&#123; origin, speed, color, angle, context &#125;) &#123; this.origin = origin this.position = &#123; ...this.origin &#125; this.color = color this.speed = speed this.angle = angle this.context = context this.renderCount = 0 &#125; draw() &#123; this.context.fillStyle = this.color this.context.beginPath() this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2) this.context.fill() &#125; move() &#123; this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3) this.renderCount++ &#125;&#125;class Boom &#123; constructor (&#123; origin, context, circleCount = 16, area &#125;) &#123; this.origin = origin this.context = context this.circleCount = circleCount this.area = area this.stop = false this.circles = [] &#125; randomArray(range) &#123; const length = range.length const randomIndex = Math.floor(length * Math.random()) return range[randomIndex] &#125; randomColor() &#123; const range = ['8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] return '#' + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) &#125; randomRange(start, end) &#123; return (end - start) * Math.random() + start &#125; init() &#123; for(let i = 0; i &lt; this.circleCount; i++) &#123; const circle = new Circle(&#123; context: this.context, origin: this.origin, color: this.randomColor(), angle: this.randomRange(Math.PI - 1, Math.PI + 1), speed: this.randomRange(1, 6) &#125;) this.circles.push(circle) &#125; &#125; move() &#123; this.circles.forEach((circle, index) =&gt; &#123; if (circle.position.x &gt; this.area.width || circle.position.y &gt; this.area.height) &#123; return this.circles.splice(index, 1) &#125; circle.move() &#125;) if (this.circles.length == 0) &#123; this.stop = true &#125; &#125; draw() &#123; this.circles.forEach(circle =&gt; circle.draw()) &#125;&#125;class CursorSpecialEffects &#123; constructor() &#123; this.computerCanvas = document.createElement('canvas') this.renderCanvas = document.createElement('canvas') this.computerContext = this.computerCanvas.getContext('2d') this.renderContext = this.renderCanvas.getContext('2d') this.globalWidth = window.innerWidth this.globalHeight = window.innerHeight this.booms = [] this.running = false &#125; handleMouseDown(e) &#123; const boom = new Boom(&#123; origin: &#123; x: e.clientX, y: e.clientY &#125;, context: this.computerContext, area: &#123; width: this.globalWidth, height: this.globalHeight &#125; &#125;) boom.init() this.booms.push(boom) this.running || this.run() &#125; handlePageHide() &#123; this.booms = [] this.running = false &#125; init() &#123; const style = this.renderCanvas.style style.position = 'fixed' style.top = style.left = 0 style.zIndex = '999999999999999999999999999999999999999999' style.pointerEvents = 'none' style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight document.body.append(this.renderCanvas) window.addEventListener('mousedown', this.handleMouseDown.bind(this)) window.addEventListener('pagehide', this.handlePageHide.bind(this)) &#125; run() &#123; this.running = true if (this.booms.length == 0) &#123; return this.running = false &#125; requestAnimationFrame(this.run.bind(this)) this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.booms.forEach((boom, index) =&gt; &#123; if (boom.stop) &#123; return this.booms.splice(index, 1) &#125; boom.move() boom.draw() &#125;) this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight) &#125;&#125;const cursorSpecialEffects = new CursorSpecialEffects()cursorSpecialEffects.init() 侧栏的固定 使用affix实现，主要参考这篇文章。 valine评论系统支持pjax 参考这个issue。 害，换个主题真的太难了，一年之内不打算再换了！ 好了，写完去睡觉啦 XD！ 2020.1.30 23:12:33 全站由github迁移到coding，国内浏览速度得到大幅提升。（香港服务器就是香啊！）","categories":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"}],"tags":[{"name":"website","slug":"website","permalink":"https://allwens.work/tags/website/"}]},{"title":"ManjaroWPS切换中文问题","slug":"wpsChangeLanguage","date":"2020-01-15T05:39:27.000Z","updated":"2020-02-04T13:46:54.000Z","comments":true,"path":"wpsChangeLanguage/","link":"","permalink":"https://allwens.work/wpsChangeLanguage/","excerpt":"wps在前几天更新之后，界面语言变成了英文，本来没有很太在意，觉得可能过几天更新就好了，但等了几天好像并没有更新的迹象，于是寻找方法进行修复…","text":"wps在前几天更新之后，界面语言变成了英文，本来没有很太在意，觉得可能过几天更新就好了，但等了几天好像并没有更新的迹象，于是寻找方法进行修复… 首先打开AUR仓库，查看wps-office有关的包，发现了wps-office-cn 查看其依赖，发现了wps-office-mui-zh-cn (optional) – zh_CN support for WPS Office 得到修复方法，即手动安装语言包： 1yay -S wps-office-mui-zh-cn 重新打开wps，不出意外的话应该已经修复成功了（因为wps优先使用系统语言），如果没有成功的话，手动点击右上角的A图标，在里面选择中文语言包进行切换即可。","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://allwens.work/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"manjaro","slug":"manjaro","permalink":"https://allwens.work/tags/manjaro/"}]},{"title":"python中文字符串居中问题","slug":"stringCenter","date":"2019-12-22T14:40:01.000Z","updated":"2020-01-26T15:43:20.000Z","comments":true,"path":"stringCenter/","link":"","permalink":"https://allwens.work/stringCenter/","excerpt":"最近在实现一个小功能的时候遇到了问题：字符串的居中输出。 虽然python有内置的字符串方法string.center()，使字符串可以居中输出，但它并不能顺利地处理中文字符串，一直无法达到让中文字符串居中的效果。","text":"最近在实现一个小功能的时候遇到了问题：字符串的居中输出。 虽然python有内置的字符串方法string.center()，使字符串可以居中输出，但它并不能顺利地处理中文字符串，一直无法达到让中文字符串居中的效果。 后来我突然醒悟，是不是因为python字符串长度的问题？用以下代码测试： 123str1='哈哈哈'str2='hhh'print(len(str1),'+',len(str2)) 输出结果居然是3+3，也就是说python将一个汉字/字母都记作一个字符，但其实它们的宽度并不相同。这样计算的话必然会导致无法正常居中，关键是要把汉字区别出来，于是我手动写了个居中函数： 1234567891011def strCenter(str, len): lst = list(str) length = 0 for item in lst: if item in string.printable: length += 1 else: length += 2 count = int((len - length) / 2) result = count * ' ' + str + count * ' ' return result 就可以正常居中啦！ 追加以下内容测试一下： 1234567a = '哈a哈a哈a哈a'b = '12345678901234567890'print(a.center(20))print(b.center(20))print(20 * '-')print(strCenter(a, 20))print(strCenter(b, 20)) 运行结果： 12345 哈a哈a哈a哈a 12345678901234567890-------------------- 哈a哈a哈a哈a 12345678901234567890 任务成功完成！","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://allwens.work/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"python","slug":"python","permalink":"https://allwens.work/tags/python/"}]},{"title":"php表单提交并自动发送邮件","slug":"formSubmit","date":"2019-10-29T13:41:34.000Z","updated":"2020-02-04T13:45:14.000Z","comments":true,"path":"formSubmit/","link":"","permalink":"https://allwens.work/formSubmit/","excerpt":"最近在html5up上淘了个主页模板，模板底有一个表单，今天在修改模板的时候，朋友提起可以配置表单实现提交表单时自动发送邮件通知，于是就萌生了这个想法，结果没想到一搞就是三四个小时（主要是因为网上的某些“教程”太坑人了！），所以记录一下配置过程给后来人参考。","text":"最近在html5up上淘了个主页模板，模板底有一个表单，今天在修改模板的时候，朋友提起可以配置表单实现提交表单时自动发送邮件通知，于是就萌生了这个想法，结果没想到一搞就是三四个小时（主要是因为网上的某些“教程”太坑人了！），所以记录一下配置过程给后来人参考。 给服务器安装php,php-fpm作者使用的是ubuntu18.04，所以使用 12sudo apt-get install phpsudo apt-get install php-fpm web服务器添加php支持作者使用的是nginx，为支持php需要修改一下配置文件，网上不少教程说要改nginx.conf，但我发现我这里的配置文件和他们的有很大差异，后来实测修改/etc/nginx/sites-available/default有效。将文件与php有关部分修改为： 123456789101112131415161718192021222324252627282930 # Add index.php to the list if you are using PHP index index.html index.htm index.nginx-debian.html index.php; server_name _; # nginx不允许静态文件响应post请求，会出现405 not allowed提示，所以需要添加以下内容# 需要开启8080端口，或者可以修改为目前已经开启的端口（或许） error_page 405 =200 @405; location @405 &#123; proxy_method GET; proxy_pass http://你的地址:8080; &#125; location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; &#125; # pass PHP scripts to FastCGI server # location ~ \\.php$ &#123; include snippets/fastcgi-php.conf; # With php-fpm (or other unix sockets): # 这里需要把php7.2修改为安装php时显示的版本 fastcgi_pass unix:/var/run/php/php7.2-fpm.sock; # With php-cgi (or other tcp sockets): # fastcgi_pass 127.0.0.1:9000; &#125; 修改表单所在的html文件接下来打开表单所在的html文件，修改form标签，例如我的： 123456789101112131415161718192021&lt;!--其实粘贴这么多只是想说form标签需要加个action=\"mail.php\"啦（滑稽）--&gt;&lt;form method=\"post\" action=\"mail.php\"&gt; &lt;div class=\"fields\"&gt; &lt;div class=\"field half\"&gt; &lt;label for=\"name\"&gt;Name&lt;/label&gt; &lt;input type=\"text\" name=\"name\" id=\"name\" /&gt; &lt;/div&gt; &lt;div class=\"field half\"&gt; &lt;label for=\"email\"&gt;Email&lt;/label&gt; &lt;input type=\"text\" name=\"email\" id=\"email\" /&gt; &lt;/div&gt; &lt;div class=\"field\"&gt; &lt;label for=\"message\"&gt;Message&lt;/label&gt; &lt;textarea name=\"message\" id=\"message\" rows=\"6\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class=\"actions\"&gt; &lt;li&gt;&lt;input type=\"submit\" value=\"Send Message\" class=\"primary\" /&gt;&lt;/li&gt; &lt;li&gt;&lt;input type=\"reset\" value=\"Clear\" /&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/form&gt; 配置mail.php文件form提交将会调用mail.php文件，接下来就需要配置它了。我浏览了许多网站，发现网上大体只有两个模板，即这个和这个。但亲身体验后发现都！不！能！用！第一个是单纯的配置文件问题，我把各项修改好后还是不能用。（或许是因为我多删了点东西？）第二个则使用了php的mail()函数，不过很不幸的是，正如这篇最后解决我问题的文章中写的一样： PHP环境下，是提供了发送邮件的函数mail()的，不过该函数要求服务器支持sendmail或者必须设置一台不需要中继的邮件发送服务器，但现在要找到一台不需要身份验证的邮件发送中继几乎不可能，所以使用mail函数往往无法成功发送电子邮件。 mail()函数确实无法成功发送邮件。这篇文章同样给出了一个解决办法，就是使用PHPMailer。 将其git clone到服务器并解压，mail.php只需按照README.md中所给的Example进行微量修改，我的大概为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php// Import PHPMailer classes into the global namespace// These must be at the top of your script, not inside a functionuse PHPMailer\\PHPMailer\\PHPMailer;use PHPMailer\\PHPMailer\\SMTP;use PHPMailer\\PHPMailer\\Exception;// 修改这三个文件的路径为服务器路径require './PHPMailer/src/Exception.php';require './PHPMailer/src/PHPMailer.php';require './PHPMailer/src/SMTP.php';// 这里将内容对应改成form标签中各项的名字$email=$_POST['email'];$name=$_POST['name'];$message=$_POST['message'];// Instantiation and passing `true` enables exceptions$mail = new PHPMailer(true);// 这里我使用的是qq邮箱，其它邮箱同理try &#123; //Server settings $mail-&gt;SMTPDebug = SMTP::DEBUG_SERVER; // Enable verbose debug output $mail-&gt;isSMTP(); // Send using SMTP $mail-&gt;Host = 'smtp.qq.com'; // Set the SMTP server to send through $mail-&gt;SMTPAuth = true; // Enable SMTP authentication $mail-&gt;Username = '邮箱的用户名'; // SMTP username $mail-&gt;Password = '邮箱的密码'; // SMTP password// $mail-&gt;SMTPSecure = PHPMailer::ENCRYPTION_STARTTLS; // Enable TLS encryption; `PHPMailer::ENCRYPTION_SMTPS` also accepted $mail-&gt;SMTPSecure = 'ssl'; $mail-&gt;Port = 465; // TCP port to connect to //Recipients $mail-&gt;setFrom('邮箱的用户名', '随便填个昵称'); $mail-&gt;addAddress('发送到的邮箱', '随便填个昵称'); // Add a recipient // 后边的那些我不用，就注释掉了// $mail-&gt;addAddress('ellen@example.com'); // Name is optional// $mail-&gt;addReplyTo('info@example.com', 'Information');// $mail-&gt;addCC('cc@example.com');// $mail-&gt;addBCC('bcc@example.com'); // Attachments// $mail-&gt;addAttachment('/var/tmp/file.tar.gz'); // Add attachments// $mail-&gt;addAttachment('/tmp/image.jpg', 'new.jpg'); // Optional name // Content $mail-&gt;isHTML(true); // Set email format to HTML $mail-&gt;Subject = \"An E-mail from $email\"; $mail-&gt;Body = \"This e-mail is written by $name : $message\"; // 我在测试时，AltBody中的内容并不会在邮件中显示出来，目前暂时不清楚有什么用 $mail-&gt;AltBody = \"\"; $mail-&gt;send(); echo 'Message has been sent';&#125; catch (Exception $e) &#123; echo \"Message could not be sent. Mailer Error: &#123;$mail-&gt;ErrorInfo&#125;\";&#125; 提交不跳转方法经过以上配置之后，你的表单应该可以正常发送邮件了，唯一的不足是在点击提交之后会跳转出现一堆提示信息，影响观感，这篇文章中给出了一种可行方法，即为form标签加入target属性并添加iframe标签。以我的表单为例，需要将form标签修改为： 1&lt;form method=\"post\" action=\"mail.php\" target=\"id_iframe\"&gt; 并在其后添加： 1&lt;iframe id=\"id_iframe\" name=\"id_iframe\" style=\"\"&gt;&lt;/iframe&gt; 这样修改虽然有效，但会在点击提交之后出现一个简陋的框体，其中显示的内容就是之前跳转后的提示信息。这没有达到我们的目的，于是想到将iframe标签隐藏，也就是将其的高度和宽度设置为0： 1&lt;iframe id=\"id_iframe\" name=\"id_iframe\" style=\"\" width=\"0\" height=\"0\"&gt;&lt;/iframe&gt; 可这样又会出现一个问题，点击按钮之后邮件到底有没有发送成功是未知的，因为所有的提示信息都被隐藏掉了，那该怎么办呢？我想到的是，将原来php文件中的两个用于输出提示信息的echo修改成echo &quot;&lt;script&gt;alert(&#39;内容&#39;)&lt;/script&gt;&quot;，也就是： 1234567echo 'Message has been sent';// 替换为echo \"&lt;script&gt;alert('Message has been sent')&lt;/script&gt;\";echo \"Message could not be sent. Mailer Error: &#123;$mail-&gt;ErrorInfo&#125;\";// 替换为echo \"&lt;script&gt;alert('Message could not be sent.')&lt;/script&gt;\"; 这样的话就可以实现网页弹窗提示邮件发送结果而不跳转了。 效果预览 结语总体来说，以上实现方式虽然可以正常使用，但是还有很大改进空间，比如提交不跳转的实现方式。不过毕竟自己没有系统学习过web方面的知识，也只能得过且过了。等什么时候能闲下来再考虑改进吧（笑）。也欢迎大家在评论里给我提建议吖！（话说这篇文章真的有人看吗？！）","categories":[{"name":"网站建设","slug":"网站建设","permalink":"https://allwens.work/categories/%E7%BD%91%E7%AB%99%E5%BB%BA%E8%AE%BE/"}],"tags":[{"name":"website","slug":"website","permalink":"https://allwens.work/tags/website/"},{"name":"php","slug":"php","permalink":"https://allwens.work/tags/php/"}]},{"title":"manjaro常用的垃圾清理命令","slug":"cleanUpFiles","date":"2019-08-12T07:17:25.000Z","updated":"2020-01-26T15:43:34.000Z","comments":true,"path":"cleanUpFiles/","link":"","permalink":"https://allwens.work/cleanUpFiles/","excerpt":"清除系统中无用的包 1sudo pacman -R $(pacman -Qdtq) 清除已下载的安装包","text":"清除系统中无用的包 1sudo pacman -R $(pacman -Qdtq) 清除已下载的安装包 1sudo pacman -Scc 日志垃圾 查看日志文件 123du -t 100M &#x2F;varorjournalctl --disk-usage 删除指定大小日志文件 1sudo journalctl --vacuum-size&#x3D;50M","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"},{"name":"manjaro","slug":"manjaro","permalink":"https://allwens.work/tags/manjaro/"}]},{"title":"禁用笔记本自带键盘的方法","slug":"disableKeyboard","date":"2019-07-03T04:13:55.000Z","updated":"2020-01-26T15:41:32.000Z","comments":true,"path":"disableKeyboard/","link":"","permalink":"https://allwens.work/disableKeyboard/","excerpt":"Windows禁用用管理员权限运行cmd，在其中输入： 1sc config i8042prt start= disabled 之后重启即可。","text":"Windows禁用用管理员权限运行cmd，在其中输入： 1sc config i8042prt start= disabled 之后重启即可。 恢复与禁用的步骤相同，把输入的命令改为： 1sc config i8042prt start= demand Linux注意：manjaro需要使用 1sudo pacman -S xorg-xinput 进行安装以使用xinput命令。 打开终端，输入xinput --list获取设备列表： 123456789101112131415161718❯ xinput --list ⎡ Virtual core pointer id=2 [master pointer (3)]⎜ ↳ Virtual core XTEST pointer id=4 [slave pointer (2)]⎜ ↳ USB Optical Mouse Mouse id=14 [slave pointer (2)]⎜ ↳ Synaptics TM3253-001 id=11 [slave pointer (2)]⎣ Virtual core keyboard id=3 [master keyboard (2)] ↳ Virtual core XTEST keyboard id=5 [slave keyboard (3)] ↳ Power Button id=6 [slave keyboard (3)] ↳ Video Bus id=7 [slave keyboard (3)] ↳ Power Button id=8 [slave keyboard (3)] ↳ Sleep Button id=9 [slave keyboard (3)] ↳ Integrated_Webcam_HD: Integrate id=10 [slave keyboard (3)] ↳ Dell WMI hotkeys id=12 [slave keyboard (3)] ↳ AT Translated Set 2 keyboard id=13 [slave keyboard (3)] ↳ DELL Wireless hotkeys id=15 [slave keyboard (3)] ↳ USB Keyboard Consumer Control id=16 [slave keyboard (3)] ↳ USB Keyboard System Control id=17 [slave keyboard (3)] ↳ USB Keyboard id=18 [slave keyboard (3)] 找到AT Translated Set 2 keyboard对应的id（本机为13）。 禁用在终端中输入 1xinput set-prop 13 \"Device Enabled\" 0 恢复在终端中输入 1xinput set-prop 13 \"Device Enabled\" 1","categories":[{"name":"系统优化","slug":"系统优化","permalink":"https://allwens.work/categories/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"windows","slug":"windows","permalink":"https://allwens.work/tags/windows/"},{"name":"linux","slug":"linux","permalink":"https://allwens.work/tags/linux/"}]}]}